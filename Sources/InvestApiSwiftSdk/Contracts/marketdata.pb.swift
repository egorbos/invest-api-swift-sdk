// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: marketdata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Тип операции со списком подписок.
public enum Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Подписаться.
  case subscribe // = 1

  ///Отписаться.
  case unsubscribe // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .subscribe
    case 2: self = .unsubscribe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .subscribe: return 1
    case .unsubscribe: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction] = [
    .unspecified,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечи.
public enum Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал свечи не определён.
  case unspecified // = 0

  ///Минутные свечи.
  case oneMinute // = 1

  ///Пятиминутные свечи.
  case fiveMinutes // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneMinute
    case 2: self = .fiveMinutes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneMinute: return 1
    case .fiveMinutes: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval] = [
    .unspecified,
    .oneMinute,
    .fiveMinutes,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Успешно.
  case success // = 1

  ///Инструмент не найден.
  case instrumentNotFound // = 2

  ///Некорректный статус подписки, список возможных значений: [SubscriptionAction](https://tinkoff.github.io/investAPI/marketdata#subscriptionaction).
  case subscriptionActionIsInvalid // = 3

  ///Некорректная глубина стакана, доступные значения: 1, 10, 20, 30, 40, 50.
  case depthIsInvalid // = 4

  ///Некорректный интервал свечей, список возможных значений: [SubscriptionInterval](https://tinkoff.github.io/investAPI/marketdata#subscriptioninterval).
  case intervalIsInvalid // = 5

  ///Превышен лимит на общее количество подписок в рамках стрима, подробнее: [Лимитная политика](https://tinkoff.github.io/investAPI/limits/).
  case limitIsExceeded // = 6

  ///Внутренняя ошибка сервиса.
  case internalError // = 7

  ///Превышен лимит на количество запросов на подписки в течение установленного отрезка времени
  case tooManyRequests // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .instrumentNotFound
    case 3: self = .subscriptionActionIsInvalid
    case 4: self = .depthIsInvalid
    case 5: self = .intervalIsInvalid
    case 6: self = .limitIsExceeded
    case 7: self = .internalError
    case 8: self = .tooManyRequests
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .instrumentNotFound: return 2
    case .subscriptionActionIsInvalid: return 3
    case .depthIsInvalid: return 4
    case .intervalIsInvalid: return 5
    case .limitIsExceeded: return 6
    case .internalError: return 7
    case .tooManyRequests: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus] = [
    .unspecified,
    .success,
    .instrumentNotFound,
    .subscriptionActionIsInvalid,
    .depthIsInvalid,
    .intervalIsInvalid,
    .limitIsExceeded,
    .internalError,
    .tooManyRequests,
  ]
}

#endif  // swift(>=4.2)

///Направление сделки.
public enum Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Направление сделки не определено.
  case unspecified // = 0

  ///Покупка.
  case buy // = 1

  ///Продажа.
  case sell // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечей.
public enum Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал не определён.
  case unspecified // = 0

  ///от 1 минуты до 1 дня.
  case candleInterval1Min // = 1

  ///от 5 минут до 1 дня.
  case candleInterval5Min // = 2

  ///от 15 минут до 1 дня.
  case candleInterval15Min // = 3

  ///от 1 часа до 1 недели.
  case hour // = 4

  ///от 1 дня до 1 года.
  case day // = 5

  ///от 2 минут до 1 дня.
  case candleInterval2Min // = 6

  ///от 3 минут до 1 дня.
  case candleInterval3Min // = 7

  ///от 10 минут до 1 дня.
  case candleInterval10Min // = 8

  ///от 30 минут до 2 дней.
  case candleInterval30Min // = 9

  ///от 2 часов до 1 месяца.
  case candleInterval2Hour // = 10

  ///от 4 часов до 1 месяца.
  case candleInterval4Hour // = 11

  ///от 1 недели до 2 лет.
  case week // = 12

  ///от 1 месяца до 10 лет.
  case month // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .candleInterval1Min
    case 2: self = .candleInterval5Min
    case 3: self = .candleInterval15Min
    case 4: self = .hour
    case 5: self = .day
    case 6: self = .candleInterval2Min
    case 7: self = .candleInterval3Min
    case 8: self = .candleInterval10Min
    case 9: self = .candleInterval30Min
    case 10: self = .candleInterval2Hour
    case 11: self = .candleInterval4Hour
    case 12: self = .week
    case 13: self = .month
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .candleInterval1Min: return 1
    case .candleInterval5Min: return 2
    case .candleInterval15Min: return 3
    case .hour: return 4
    case .day: return 5
    case .candleInterval2Min: return 6
    case .candleInterval3Min: return 7
    case .candleInterval10Min: return 8
    case .candleInterval30Min: return 9
    case .candleInterval2Hour: return 10
    case .candleInterval4Hour: return 11
    case .week: return 12
    case .month: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval] = [
    .unspecified,
    .candleInterval1Min,
    .candleInterval5Min,
    .candleInterval15Min,
    .hour,
    .day,
    .candleInterval2Min,
    .candleInterval3Min,
    .candleInterval10Min,
    .candleInterval30Min,
    .candleInterval2Hour,
    .candleInterval4Hour,
    .week,
    .month,
  ]
}

#endif  // swift(>=4.2)

///Запрос подписки или отписки на определённые биржевые данные.
public struct Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest.OneOf_Payload? = nil

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest {
    get {
      if case .subscribeCandlesRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest()
    }
    set {payload = .subscribeCandlesRequest(newValue)}
  }

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest {
    get {
      if case .subscribeOrderBookRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest()
    }
    set {payload = .subscribeOrderBookRequest(newValue)}
  }

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest {
    get {
      if case .subscribeTradesRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest()
    }
    set {payload = .subscribeTradesRequest(newValue)}
  }

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest {
    get {
      if case .subscribeInfoRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest()
    }
    set {payload = .subscribeInfoRequest(newValue)}
  }

  ///Запрос подписки на цены последних сделок.
  public var subscribeLastPriceRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest {
    get {
      if case .subscribeLastPriceRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest()
    }
    set {payload = .subscribeLastPriceRequest(newValue)}
  }

  ///Запрос своих подписок.
  public var getMySubscriptions: Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions {
    get {
      if case .getMySubscriptions(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions()
    }
    set {payload = .getMySubscriptions(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Запрос подписки на свечи.
    case subscribeCandlesRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest)
    ///Запрос подписки на стаканы.
    case subscribeOrderBookRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest)
    ///Запрос подписки на ленту обезличенных сделок.
    case subscribeTradesRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest)
    ///Запрос подписки на торговые статусы инструментов.
    case subscribeInfoRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest)
    ///Запрос подписки на цены последних сделок.
    case subscribeLastPriceRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest)
    ///Запрос своих подписок.
    case getMySubscriptions(Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesRequest, .subscribeCandlesRequest): return {
        guard case .subscribeCandlesRequest(let l) = lhs, case .subscribeCandlesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookRequest, .subscribeOrderBookRequest): return {
        guard case .subscribeOrderBookRequest(let l) = lhs, case .subscribeOrderBookRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesRequest, .subscribeTradesRequest): return {
        guard case .subscribeTradesRequest(let l) = lhs, case .subscribeTradesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoRequest, .subscribeInfoRequest): return {
        guard case .subscribeInfoRequest(let l) = lhs, case .subscribeInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeLastPriceRequest, .subscribeLastPriceRequest): return {
        guard case .subscribeLastPriceRequest(let l) = lhs, case .subscribeLastPriceRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getMySubscriptions, .getMySubscriptions): return {
        guard case .getMySubscriptions(let l) = lhs, case .getMySubscriptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_MarketDataServerSideStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest {
    get {return _subscribeCandlesRequest ?? Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest()}
    set {_subscribeCandlesRequest = newValue}
  }
  /// Returns true if `subscribeCandlesRequest` has been explicitly set.
  public var hasSubscribeCandlesRequest: Bool {return self._subscribeCandlesRequest != nil}
  /// Clears the value of `subscribeCandlesRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeCandlesRequest() {self._subscribeCandlesRequest = nil}

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest {
    get {return _subscribeOrderBookRequest ?? Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest()}
    set {_subscribeOrderBookRequest = newValue}
  }
  /// Returns true if `subscribeOrderBookRequest` has been explicitly set.
  public var hasSubscribeOrderBookRequest: Bool {return self._subscribeOrderBookRequest != nil}
  /// Clears the value of `subscribeOrderBookRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeOrderBookRequest() {self._subscribeOrderBookRequest = nil}

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest {
    get {return _subscribeTradesRequest ?? Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest()}
    set {_subscribeTradesRequest = newValue}
  }
  /// Returns true if `subscribeTradesRequest` has been explicitly set.
  public var hasSubscribeTradesRequest: Bool {return self._subscribeTradesRequest != nil}
  /// Clears the value of `subscribeTradesRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeTradesRequest() {self._subscribeTradesRequest = nil}

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest {
    get {return _subscribeInfoRequest ?? Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest()}
    set {_subscribeInfoRequest = newValue}
  }
  /// Returns true if `subscribeInfoRequest` has been explicitly set.
  public var hasSubscribeInfoRequest: Bool {return self._subscribeInfoRequest != nil}
  /// Clears the value of `subscribeInfoRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeInfoRequest() {self._subscribeInfoRequest = nil}

  ///Запрос подписки на цены последних сделок.
  public var subscribeLastPriceRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest {
    get {return _subscribeLastPriceRequest ?? Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest()}
    set {_subscribeLastPriceRequest = newValue}
  }
  /// Returns true if `subscribeLastPriceRequest` has been explicitly set.
  public var hasSubscribeLastPriceRequest: Bool {return self._subscribeLastPriceRequest != nil}
  /// Clears the value of `subscribeLastPriceRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeLastPriceRequest() {self._subscribeLastPriceRequest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subscribeCandlesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest? = nil
  fileprivate var _subscribeOrderBookRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest? = nil
  fileprivate var _subscribeTradesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest? = nil
  fileprivate var _subscribeInfoRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest? = nil
  fileprivate var _subscribeLastPriceRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest? = nil
}

///Пакет биржевой информации по подписке.
public struct Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse.OneOf_Payload? = nil

  ///Результат подписки на свечи.
  public var subscribeCandlesResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse {
    get {
      if case .subscribeCandlesResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse()
    }
    set {payload = .subscribeCandlesResponse(newValue)}
  }

  ///Результат подписки на стаканы.
  public var subscribeOrderBookResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse {
    get {
      if case .subscribeOrderBookResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse()
    }
    set {payload = .subscribeOrderBookResponse(newValue)}
  }

  ///Результат подписки на поток обезличенных сделок.
  public var subscribeTradesResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse {
    get {
      if case .subscribeTradesResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse()
    }
    set {payload = .subscribeTradesResponse(newValue)}
  }

  ///Результат подписки на торговые статусы инструментов.
  public var subscribeInfoResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse {
    get {
      if case .subscribeInfoResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse()
    }
    set {payload = .subscribeInfoResponse(newValue)}
  }

  ///Свеча.
  public var candle: Tinkoff_Public_Invest_Api_Contract_V1_Candle {
    get {
      if case .candle(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Candle()
    }
    set {payload = .candle(newValue)}
  }

  ///Сделки.
  public var trade: Tinkoff_Public_Invest_Api_Contract_V1_Trade {
    get {
      if case .trade(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Trade()
    }
    set {payload = .trade(newValue)}
  }

  ///Стакан.
  public var orderbook: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook {
    get {
      if case .orderbook(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_OrderBook()
    }
    set {payload = .orderbook(newValue)}
  }

  ///Торговый статус.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus {
    get {
      if case .tradingStatus(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus()
    }
    set {payload = .tradingStatus(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Tinkoff_Public_Invest_Api_Contract_V1_Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Ping()
    }
    set {payload = .ping(newValue)}
  }

  ///Результат подписки на цены последние сделок по инструментам.
  public var subscribeLastPriceResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse {
    get {
      if case .subscribeLastPriceResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse()
    }
    set {payload = .subscribeLastPriceResponse(newValue)}
  }

  ///Цена последней сделки.
  public var lastPrice: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice {
    get {
      if case .lastPrice(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_LastPrice()
    }
    set {payload = .lastPrice(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Результат подписки на свечи.
    case subscribeCandlesResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse)
    ///Результат подписки на стаканы.
    case subscribeOrderBookResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse)
    ///Результат подписки на поток обезличенных сделок.
    case subscribeTradesResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse)
    ///Результат подписки на торговые статусы инструментов.
    case subscribeInfoResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse)
    ///Свеча.
    case candle(Tinkoff_Public_Invest_Api_Contract_V1_Candle)
    ///Сделки.
    case trade(Tinkoff_Public_Invest_Api_Contract_V1_Trade)
    ///Стакан.
    case orderbook(Tinkoff_Public_Invest_Api_Contract_V1_OrderBook)
    ///Торговый статус.
    case tradingStatus(Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus)
    ///Проверка активности стрима.
    case ping(Tinkoff_Public_Invest_Api_Contract_V1_Ping)
    ///Результат подписки на цены последние сделок по инструментам.
    case subscribeLastPriceResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse)
    ///Цена последней сделки.
    case lastPrice(Tinkoff_Public_Invest_Api_Contract_V1_LastPrice)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesResponse, .subscribeCandlesResponse): return {
        guard case .subscribeCandlesResponse(let l) = lhs, case .subscribeCandlesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookResponse, .subscribeOrderBookResponse): return {
        guard case .subscribeOrderBookResponse(let l) = lhs, case .subscribeOrderBookResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesResponse, .subscribeTradesResponse): return {
        guard case .subscribeTradesResponse(let l) = lhs, case .subscribeTradesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoResponse, .subscribeInfoResponse): return {
        guard case .subscribeInfoResponse(let l) = lhs, case .subscribeInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.candle, .candle): return {
        guard case .candle(let l) = lhs, case .candle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trade, .trade): return {
        guard case .trade(let l) = lhs, case .trade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderbook, .orderbook): return {
        guard case .orderbook(let l) = lhs, case .orderbook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tradingStatus, .tradingStatus): return {
        guard case .tradingStatus(let l) = lhs, case .tradingStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeLastPriceResponse, .subscribeLastPriceResponse): return {
        guard case .subscribeLastPriceResponse(let l) = lhs, case .subscribeLastPriceResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lastPrice, .lastPrice): return {
        guard case .lastPrice(let l) = lhs, case .lastPrice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// subscribeCandles | Изменения статуса подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на свечи.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument] = []

  ///Флаг ожидания закрытия временного интервала для отправки свечи, применяется только для минутных свечей.
  public var waitingClose: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос изменения статус подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval = .unspecified

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статус подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на свечи.
  public var candlesSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval = .unspecified

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос на изменение статуса подписки на стаканы.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на стаканы.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на стаканы.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на стаканы.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на стаканы.
  public var orderBookSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на поток обезличенных сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на поток обезличенных сделок.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на поток обезличенных сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на поток обезличенных сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на поток сделок.
  public var tradeSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на торговый статус инструмента.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на торговый статус.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на торговый статус.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на торговый статус.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на торговый статус.
  public var infoSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на цену последней сделки по инструменту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на цену последней сделки.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на последнюю цену.
public struct Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на цену последней сделки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на цену последней сделки.
  public var lastPriceSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на цену последней сделки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Пакет свечей в рамках стрима.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Candle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечи.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval = .unspecified

  ///Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var `open`: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _open ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _high ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _low ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _close ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём сделок в лотах.
  public var volume: Int64 = 0

  ///Время начала интервала свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Время последней сделки, вошедшей в свечу в часовом поясе UTC.
  public var lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastTradeTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastTradeTs = newValue}
  }
  /// Returns true if `lastTradeTs` has been explicitly set.
  public var hasLastTradeTs: Bool {return self._lastTradeTs != nil}
  /// Clears the value of `lastTradeTs`. Subsequent reads from it will return its default value.
  public mutating func clearLastTradeTs() {self._lastTradeTs = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет стаканов в рамках стрима.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Флаг консистентности стакана. **false** значит не все заявки попали в стакан по причинам сетевых задержек или нарушения порядка доставки.
  public var isConsistent: Bool = false

  ///Массив предложений.
  public var bids: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []

  ///Массив спроса.
  public var asks: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []

  ///Время формирования стакана в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _limitUp ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return self._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {self._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _limitDown ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return self._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {self._limitDown = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Массив предложений/спроса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество в лотах.
  public var quantity: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Информация о сделке.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Trade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Направление сделки.
  public var direction: Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection = .unspecified

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество лотов.
  public var quantity: Int64 = 0

  ///Время сделки в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет изменения торгового статуса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified

  ///Время изменения торгового статуса в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос исторических свечей.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Интервал запрошенных свечей.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval = .unspecified

  ///Идентификатор инструмента, принимает значение figi или instrument_uid.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список свечей.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив свечей.
  public var candles: [Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о свече.
public struct Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var `open`: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _open ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _high ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _low ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _close ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём торгов в лотах.
  public var volume: Int64 = 0

  ///Время свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак завершённости свечи. **false** значит, свеча за текущие интервал ещё сформирована не полностью.
  public var isComplete: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос получения цен последних сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: [String] = []

  ///Массив идентификаторов инструмента, принимает значения figi или instrument_uid.
  public var instrumentID: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список цен последних сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив цен последних сделок.
  public var lastPrices: [Tinkoff_Public_Invest_Api_Contract_V1_LastPrice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о цене последней сделки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_LastPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi инструмента.
  public var figi: String = String()

  ///Цена последней сделки за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Время получения последней цены в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос стакана.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Идентификатор инструмента, принимает значение figi или instrument_uid.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о стакане.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Глубина стакана.
  public var depth: Int32 {
    get {return _storage._depth}
    set {_uniqueStorage()._depth = newValue}
  }

  ///Множество пар значений на покупку.
  public var bids: [Tinkoff_Public_Invest_Api_Contract_V1_Order] {
    get {return _storage._bids}
    set {_uniqueStorage()._bids = newValue}
  }

  ///Множество пар значений на продажу.
  public var asks: [Tinkoff_Public_Invest_Api_Contract_V1_Order] {
    get {return _storage._asks}
    set {_uniqueStorage()._asks = newValue}
  }

  ///Цена последней сделки за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var lastPrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._lastPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._lastPrice = newValue}
  }
  /// Returns true if `lastPrice` has been explicitly set.
  public var hasLastPrice: Bool {return _storage._lastPrice != nil}
  /// Clears the value of `lastPrice`. Subsequent reads from it will return its default value.
  public mutating func clearLastPrice() {_uniqueStorage()._lastPrice = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var closePrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._closePrice ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._closePrice = newValue}
  }
  /// Returns true if `closePrice` has been explicitly set.
  public var hasClosePrice: Bool {return _storage._closePrice != nil}
  /// Clears the value of `closePrice`. Subsequent reads from it will return its default value.
  public mutating func clearClosePrice() {_uniqueStorage()._closePrice = nil}

  ///Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._limitUp ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return _storage._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {_uniqueStorage()._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._limitDown ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return _storage._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {_uniqueStorage()._limitDown = nil}

  ///Время получения цены последней сделки.
  public var lastPriceTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastPriceTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastPriceTs = newValue}
  }
  /// Returns true if `lastPriceTs` has been explicitly set.
  public var hasLastPriceTs: Bool {return _storage._lastPriceTs != nil}
  /// Clears the value of `lastPriceTs`. Subsequent reads from it will return its default value.
  public mutating func clearLastPriceTs() {_uniqueStorage()._lastPriceTs = nil}

  ///Время получения цены закрытия.
  public var closePriceTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._closePriceTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._closePriceTs = newValue}
  }
  /// Returns true if `closePriceTs` has been explicitly set.
  public var hasClosePriceTs: Bool {return _storage._closePriceTs != nil}
  /// Clears the value of `closePriceTs`. Subsequent reads from it will return its default value.
  public mutating func clearClosePriceTs() {_uniqueStorage()._closePriceTs = nil}

  ///Время формирования стакана на бирже.
  public var orderbookTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._orderbookTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._orderbookTs = newValue}
  }
  /// Returns true if `orderbookTs` has been explicitly set.
  public var hasOrderbookTs: Bool {return _storage._orderbookTs != nil}
  /// Clears the value of `orderbookTs`. Subsequent reads from it will return its default value.
  public mutating func clearOrderbookTs() {_uniqueStorage()._orderbookTs = nil}

  ///Uid инструмента.
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос получения торгового статуса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос получения торгового статуса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о торговом статусе.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив информации о торговых статусах
  public var tradingStatuses: [Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о торговом статусе.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool = false

  ///Uid инструмента.
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос обезличенных сделок за последний час.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Идентификатор инструмента, принимает значение figi или instrument_uid.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Обезличенных сделок за последний час.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив сделок.
  public var trades: [Tinkoff_Public_Invest_Api_Contract_V1_Trade] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос активных подписок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос цен закрытия торговой сессии по инструментам.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив по инструментам.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос цен закрытия торговой сессии по инструменту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента, принимает значение figi или instrument_uid.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Цены закрытия торговой сессии по инструментам.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив по инструментам.
  public var closePrices: [Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Цена закрытия торговой сессии по инструменту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi инструмента.
  public var figi: String = String()

  ///Uid инструмента.
  public var instrumentUid: String = String()

  ///Цена закрытия торговой сессии.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Дата совершения торгов.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataServerSideStreamRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_Candle: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBook: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_Order: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_Trade: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_LastPrice: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_ACTION_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_ACTION_SUBSCRIBE"),
    2: .same(proto: "SUBSCRIPTION_ACTION_UNSUBSCRIBE"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_INTERVAL_ONE_MINUTE"),
    2: .same(proto: "SUBSCRIPTION_INTERVAL_FIVE_MINUTES"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND"),
    3: .same(proto: "SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID"),
    4: .same(proto: "SUBSCRIPTION_STATUS_DEPTH_IS_INVALID"),
    5: .same(proto: "SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID"),
    6: .same(proto: "SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED"),
    7: .same(proto: "SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
    8: .same(proto: "SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRADE_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "TRADE_DIRECTION_BUY"),
    2: .same(proto: "TRADE_DIRECTION_SELL"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANDLE_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "CANDLE_INTERVAL_1_MIN"),
    2: .same(proto: "CANDLE_INTERVAL_5_MIN"),
    3: .same(proto: "CANDLE_INTERVAL_15_MIN"),
    4: .same(proto: "CANDLE_INTERVAL_HOUR"),
    5: .same(proto: "CANDLE_INTERVAL_DAY"),
    6: .same(proto: "CANDLE_INTERVAL_2_MIN"),
    7: .same(proto: "CANDLE_INTERVAL_3_MIN"),
    8: .same(proto: "CANDLE_INTERVAL_10_MIN"),
    9: .same(proto: "CANDLE_INTERVAL_30_MIN"),
    10: .same(proto: "CANDLE_INTERVAL_2_HOUR"),
    11: .same(proto: "CANDLE_INTERVAL_4_HOUR"),
    12: .same(proto: "CANDLE_INTERVAL_WEEK"),
    13: .same(proto: "CANDLE_INTERVAL_MONTH"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
    5: .standard(proto: "subscribe_last_price_request"),
    6: .standard(proto: "get_my_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesRequest(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookRequest(v)
        }
      }()
      case 3: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesRequest(v)
        }
      }()
      case 4: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoRequest(v)
        }
      }()
      case 5: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceRequest(v)
        }
      }()
      case 6: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getMySubscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getMySubscriptions(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesRequest?: try {
      guard case .subscribeCandlesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookRequest?: try {
      guard case .subscribeOrderBookRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesRequest?: try {
      guard case .subscribeTradesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoRequest?: try {
      guard case .subscribeInfoRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .subscribeLastPriceRequest?: try {
      guard case .subscribeLastPriceRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getMySubscriptions?: try {
      guard case .getMySubscriptions(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataServerSideStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataServerSideStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
    5: .standard(proto: "subscribe_last_price_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscribeCandlesRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subscribeOrderBookRequest) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._subscribeTradesRequest) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._subscribeInfoRequest) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._subscribeLastPriceRequest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscribeCandlesRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subscribeOrderBookRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._subscribeTradesRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._subscribeInfoRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._subscribeLastPriceRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataServerSideStreamRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataServerSideStreamRequest) -> Bool {
    if lhs._subscribeCandlesRequest != rhs._subscribeCandlesRequest {return false}
    if lhs._subscribeOrderBookRequest != rhs._subscribeOrderBookRequest {return false}
    if lhs._subscribeTradesRequest != rhs._subscribeTradesRequest {return false}
    if lhs._subscribeInfoRequest != rhs._subscribeInfoRequest {return false}
    if lhs._subscribeLastPriceRequest != rhs._subscribeLastPriceRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_response"),
    2: .standard(proto: "subscribe_order_book_response"),
    3: .standard(proto: "subscribe_trades_response"),
    4: .standard(proto: "subscribe_info_response"),
    5: .same(proto: "candle"),
    6: .same(proto: "trade"),
    7: .same(proto: "orderbook"),
    8: .standard(proto: "trading_status"),
    9: .same(proto: "ping"),
    10: .standard(proto: "subscribe_last_price_response"),
    11: .standard(proto: "last_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesResponse(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookResponse(v)
        }
      }()
      case 3: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesResponse(v)
        }
      }()
      case 4: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoResponse(v)
        }
      }()
      case 5: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Candle?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .candle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .candle(v)
        }
      }()
      case 6: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Trade?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .trade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .trade(v)
        }
      }()
      case 7: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderbook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderbook(v)
        }
      }()
      case 8: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tradingStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tradingStatus(v)
        }
      }()
      case 9: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 10: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceResponse(v)
        }
      }()
      case 11: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .lastPrice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .lastPrice(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesResponse?: try {
      guard case .subscribeCandlesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookResponse?: try {
      guard case .subscribeOrderBookResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesResponse?: try {
      guard case .subscribeTradesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoResponse?: try {
      guard case .subscribeInfoResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .candle?: try {
      guard case .candle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .trade?: try {
      guard case .trade(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .orderbook?: try {
      guard case .orderbook(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .tradingStatus?: try {
      guard case .tradingStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .subscribeLastPriceResponse?: try {
      guard case .subscribeLastPriceResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .lastPrice?: try {
      guard case .lastPrice(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
    3: .standard(proto: "waiting_close"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.waitingClose) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    if self.waitingClose != false {
      try visitor.visitSingularBoolField(value: self.waitingClose, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.waitingClose != rhs.waitingClose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "candles_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.candlesSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.candlesSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candlesSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.candlesSubscriptions != rhs.candlesSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "subscription_status"),
    4: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "order_book_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orderBookSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.orderBookSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBookSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.orderBookSubscriptions != rhs.orderBookSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "subscription_status"),
    4: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "trade_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tradeSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.tradeSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradeSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.tradeSubscriptions != rhs.tradeSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "info_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infoSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.infoSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.infoSubscriptions != rhs.infoSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "last_price_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lastPriceSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.lastPriceSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPriceSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.lastPriceSubscriptions != rhs.lastPriceSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Candle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Candle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .same(proto: "open"),
    4: .same(proto: "high"),
    5: .same(proto: "low"),
    6: .same(proto: "close"),
    7: .same(proto: "volume"),
    8: .same(proto: "time"),
    9: .standard(proto: "last_trade_ts"),
    10: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._lastTradeTs) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 7)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._lastTradeTs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Candle, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Candle) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs._lastTradeTs != rhs._lastTradeTs {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "is_consistent"),
    4: .same(proto: "bids"),
    5: .same(proto: "asks"),
    6: .same(proto: "time"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
    9: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isConsistent) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._limitUp) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._limitDown) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.isConsistent != false {
      try visitor.visitSingularBoolField(value: self.isConsistent, fieldNumber: 3)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 4)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._limitUp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._limitDown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.isConsistent != rhs.isConsistent {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs._time != rhs._time {return false}
    if lhs._limitUp != rhs._limitUp {return false}
    if lhs._limitDown != rhs._limitDown {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Order, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Order) -> Bool {
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Trade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "direction"),
    3: .same(proto: "price"),
    4: .same(proto: "quantity"),
    5: .same(proto: "time"),
    6: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 4)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Trade, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Trade) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._time != rhs._time {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .same(proto: "time"),
    4: .standard(proto: "limit_order_available_flag"),
    5: .standard(proto: "market_order_available_flag"),
    6: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 4)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 5)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs._time != rhs._time {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "interval"),
    5: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 4)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.candles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse) -> Bool {
    if lhs.candles != rhs.candles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricCandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "high"),
    3: .same(proto: "low"),
    4: .same(proto: "close"),
    5: .same(proto: "volume"),
    6: .same(proto: "time"),
    7: .standard(proto: "is_complete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isComplete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.isComplete != false {
      try visitor.visitSingularBoolField(value: self.isComplete, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle, rhs: Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle) -> Bool {
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs.isComplete != rhs.isComplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitRepeatedStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lastPrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse) -> Bool {
    if lhs.lastPrices != rhs.lastPrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_LastPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
    11: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice, rhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._price != rhs._price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .same(proto: "bids"),
    4: .same(proto: "asks"),
    5: .standard(proto: "last_price"),
    6: .standard(proto: "close_price"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
    21: .standard(proto: "last_price_ts"),
    22: .standard(proto: "close_price_ts"),
    23: .standard(proto: "orderbook_ts"),
    9: .standard(proto: "instrument_uid"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _depth: Int32 = 0
    var _bids: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []
    var _asks: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []
    var _lastPrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _closePrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _lastPriceTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closePriceTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _orderbookTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _instrumentUid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _depth = source._depth
      _bids = source._bids
      _asks = source._asks
      _lastPrice = source._lastPrice
      _closePrice = source._closePrice
      _limitUp = source._limitUp
      _limitDown = source._limitDown
      _lastPriceTs = source._lastPriceTs
      _closePriceTs = source._closePriceTs
      _orderbookTs = source._orderbookTs
      _instrumentUid = source._instrumentUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._depth) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._bids) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._asks) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lastPrice) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._closePrice) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._limitUp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._limitDown) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._lastPriceTs) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._closePriceTs) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._orderbookTs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if _storage._depth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._depth, fieldNumber: 2)
      }
      if !_storage._bids.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bids, fieldNumber: 3)
      }
      if !_storage._asks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._asks, fieldNumber: 4)
      }
      try { if let v = _storage._lastPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._closePrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._limitUp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._limitDown {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 9)
      }
      try { if let v = _storage._lastPriceTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._closePriceTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._orderbookTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._depth != rhs_storage._depth {return false}
        if _storage._bids != rhs_storage._bids {return false}
        if _storage._asks != rhs_storage._asks {return false}
        if _storage._lastPrice != rhs_storage._lastPrice {return false}
        if _storage._closePrice != rhs_storage._closePrice {return false}
        if _storage._limitUp != rhs_storage._limitUp {return false}
        if _storage._limitDown != rhs_storage._limitDown {return false}
        if _storage._lastPriceTs != rhs_storage._lastPriceTs {return false}
        if _storage._closePriceTs != rhs_storage._closePriceTs {return false}
        if _storage._orderbookTs != rhs_storage._orderbookTs {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instrumentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trading_statuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tradingStatuses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tradingStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradingStatuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusesResponse) -> Bool {
    if lhs.tradingStatuses != rhs.tradingStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .standard(proto: "limit_order_available_flag"),
    4: .standard(proto: "market_order_available_flag"),
    5: .standard(proto: "api_trade_available_flag"),
    6: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.apiTradeAvailableFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 3)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 4)
    }
    if self.apiTradeAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.apiTradeAvailableFlag, fieldNumber: 5)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.apiTradeAvailableFlag != rhs.apiTradeAvailableFlag {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trades"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse) -> Bool {
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMySubscriptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetMySubscriptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClosePricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesRequest) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentClosePriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClosePricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "close_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.closePrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closePrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closePrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetClosePricesResponse) -> Bool {
    if lhs.closePrices != rhs.closePrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentClosePriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_uid"),
    11: .same(proto: "price"),
    21: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentClosePriceResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs._price != rhs._price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
