// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: operations.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Статус запрашиваемых операций.
public enum Tinkoff_Public_Invest_Api_Contract_V1_OperationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус операции не определён
  case unspecified // = 0

  ///Исполнена.
  case executed // = 1

  ///Отменена.
  case canceled // = 2

  ///Исполняется.
  case progress // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .executed
    case 2: self = .canceled
    case 3: self = .progress
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .executed: return 1
    case .canceled: return 2
    case .progress: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_OperationState] = [
    .unspecified,
    .executed,
    .canceled,
    .progress,
  ]
}

#endif  // swift(>=4.2)

///Тип операции.
public enum Tinkoff_Public_Invest_Api_Contract_V1_OperationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип операции не определён.
  case unspecified // = 0

  ///Пополнение брокерского счёта.
  case input // = 1

  ///Удержание НДФЛ по купонам.
  case bondTax // = 2

  ///Вывод ЦБ.
  case outputSecurities // = 3

  ///Доход по сделке РЕПО овернайт.
  case overnight // = 4

  ///Удержание налога.
  case tax // = 5

  ///Полное погашение облигаций.
  case bondRepaymentFull // = 6

  ///Продажа ЦБ с карты.
  case sellCard // = 7

  ///Удержание налога по дивидендам.
  case dividendTax // = 8

  ///Вывод денежных средств.
  case output // = 9

  ///Частичное погашение облигаций.
  case bondRepayment // = 10

  ///Корректировка налога.
  case taxCorrection // = 11

  ///Удержание комиссии за обслуживание брокерского счёта.
  case serviceFee // = 12

  ///Удержание налога за материальную выгоду.
  case benefitTax // = 13

  ///Удержание комиссии за непокрытую позицию.
  case marginFee // = 14

  ///Покупка ЦБ.
  case buy // = 15

  ///Покупка ЦБ с карты.
  case buyCard // = 16

  ///Перевод ценных бумаг из другого депозитария.
  case inputSecurities // = 17

  ///Продажа в результате Margin-call.
  case sellMargin // = 18

  ///Удержание комиссии за операцию.
  case brokerFee // = 19

  ///Покупка в результате Margin-call.
  case buyMargin // = 20

  ///Выплата дивидендов.
  case dividend // = 21

  ///Продажа ЦБ.
  case sell // = 22

  ///Выплата купонов.
  case coupon // = 23

  ///Удержание комиссии SuccessFee.
  case successFee // = 24

  ///Передача дивидендного дохода.
  case dividendTransfer // = 25

  ///Зачисление вариационной маржи.
  case accruingVarmargin // = 26

  ///Списание вариационной маржи.
  case writingOffVarmargin // = 27

  ///Покупка в рамках экспирации фьючерсного контракта.
  case deliveryBuy // = 28

  ///Продажа в рамках экспирации фьючерсного контракта.
  case deliverySell // = 29

  ///Комиссия за управление по счёту автоследования.
  case trackMfee // = 30

  ///Комиссия за результат по счёту автоследования.
  case trackPfee // = 31

  ///Удержание налога по ставке 15%.
  case taxProgressive // = 32

  ///Удержание налога по купонам по ставке 15%.
  case bondTaxProgressive // = 33

  ///Удержание налога по дивидендам по ставке 15%.
  case dividendTaxProgressive // = 34

  ///Удержание налога за материальную выгоду по ставке 15%.
  case benefitTaxProgressive // = 35

  ///Корректировка налога по ставке 15%.
  case taxCorrectionProgressive // = 36

  ///Удержание налога за возмещение по сделкам РЕПО по ставке 15%.
  case taxRepoProgressive // = 37

  ///Удержание налога за возмещение по сделкам РЕПО.
  case taxRepo // = 38

  ///Удержание налога по сделкам РЕПО.
  case taxRepoHold // = 39

  ///Возврат налога по сделкам РЕПО.
  case taxRepoRefund // = 40

  ///Удержание налога по сделкам РЕПО по ставке 15%.
  case taxRepoHoldProgressive // = 41

  ///Возврат налога по сделкам РЕПО по ставке 15%.
  case taxRepoRefundProgressive // = 42

  ///Выплата дивидендов на карту.
  case divExt // = 43

  ///Корректировка налога по купонам.
  case taxCorrectionCoupon // = 44

  ///Комиссия за валютный остаток.
  case cashFee // = 45

  ///Комиссия за вывод валюты с брокерского счета.
  case outFee // = 46

  ///Гербовый сбор.
  case outStampDuty // = 47

  ///	SWIFT-перевод
  case outputSwift // = 50

  ///	SWIFT-перевод
  case inputSwift // = 51

  ///  Перевод на карту
  case outputAcquiring // = 53

  ///	Перевод с карты
  case inputAcquiring // = 54

  ///	Комиссия за вывод средств
  case outputPenalty // = 55

  ///	Списание оплаты за сервис Советов
  case adviceFee // = 56

  ///  Перевод ценных бумаг с ИИС на Брокерский счет
  case transIisBs // = 57

  ///  Перевод ценных бумаг с одного брокерского счета на другой
  case transBsBs // = 58

  ///  Вывод денежных средств со счета
  case outMulti // = 59

  ///  Пополнение денежных средств со счета
  case inpMulti // = 60

  ///  Размещение биржевого овернайта
  case overPlacement // = 61

  ///  Списание комиссии
  case overCom // = 62

  ///  Доход от оверанайта
  case overIncome // = 63

  /// Экспирация
  case optionExpiration // = 64
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .input
    case 2: self = .bondTax
    case 3: self = .outputSecurities
    case 4: self = .overnight
    case 5: self = .tax
    case 6: self = .bondRepaymentFull
    case 7: self = .sellCard
    case 8: self = .dividendTax
    case 9: self = .output
    case 10: self = .bondRepayment
    case 11: self = .taxCorrection
    case 12: self = .serviceFee
    case 13: self = .benefitTax
    case 14: self = .marginFee
    case 15: self = .buy
    case 16: self = .buyCard
    case 17: self = .inputSecurities
    case 18: self = .sellMargin
    case 19: self = .brokerFee
    case 20: self = .buyMargin
    case 21: self = .dividend
    case 22: self = .sell
    case 23: self = .coupon
    case 24: self = .successFee
    case 25: self = .dividendTransfer
    case 26: self = .accruingVarmargin
    case 27: self = .writingOffVarmargin
    case 28: self = .deliveryBuy
    case 29: self = .deliverySell
    case 30: self = .trackMfee
    case 31: self = .trackPfee
    case 32: self = .taxProgressive
    case 33: self = .bondTaxProgressive
    case 34: self = .dividendTaxProgressive
    case 35: self = .benefitTaxProgressive
    case 36: self = .taxCorrectionProgressive
    case 37: self = .taxRepoProgressive
    case 38: self = .taxRepo
    case 39: self = .taxRepoHold
    case 40: self = .taxRepoRefund
    case 41: self = .taxRepoHoldProgressive
    case 42: self = .taxRepoRefundProgressive
    case 43: self = .divExt
    case 44: self = .taxCorrectionCoupon
    case 45: self = .cashFee
    case 46: self = .outFee
    case 47: self = .outStampDuty
    case 50: self = .outputSwift
    case 51: self = .inputSwift
    case 53: self = .outputAcquiring
    case 54: self = .inputAcquiring
    case 55: self = .outputPenalty
    case 56: self = .adviceFee
    case 57: self = .transIisBs
    case 58: self = .transBsBs
    case 59: self = .outMulti
    case 60: self = .inpMulti
    case 61: self = .overPlacement
    case 62: self = .overCom
    case 63: self = .overIncome
    case 64: self = .optionExpiration
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .input: return 1
    case .bondTax: return 2
    case .outputSecurities: return 3
    case .overnight: return 4
    case .tax: return 5
    case .bondRepaymentFull: return 6
    case .sellCard: return 7
    case .dividendTax: return 8
    case .output: return 9
    case .bondRepayment: return 10
    case .taxCorrection: return 11
    case .serviceFee: return 12
    case .benefitTax: return 13
    case .marginFee: return 14
    case .buy: return 15
    case .buyCard: return 16
    case .inputSecurities: return 17
    case .sellMargin: return 18
    case .brokerFee: return 19
    case .buyMargin: return 20
    case .dividend: return 21
    case .sell: return 22
    case .coupon: return 23
    case .successFee: return 24
    case .dividendTransfer: return 25
    case .accruingVarmargin: return 26
    case .writingOffVarmargin: return 27
    case .deliveryBuy: return 28
    case .deliverySell: return 29
    case .trackMfee: return 30
    case .trackPfee: return 31
    case .taxProgressive: return 32
    case .bondTaxProgressive: return 33
    case .dividendTaxProgressive: return 34
    case .benefitTaxProgressive: return 35
    case .taxCorrectionProgressive: return 36
    case .taxRepoProgressive: return 37
    case .taxRepo: return 38
    case .taxRepoHold: return 39
    case .taxRepoRefund: return 40
    case .taxRepoHoldProgressive: return 41
    case .taxRepoRefundProgressive: return 42
    case .divExt: return 43
    case .taxCorrectionCoupon: return 44
    case .cashFee: return 45
    case .outFee: return 46
    case .outStampDuty: return 47
    case .outputSwift: return 50
    case .inputSwift: return 51
    case .outputAcquiring: return 53
    case .inputAcquiring: return 54
    case .outputPenalty: return 55
    case .adviceFee: return 56
    case .transIisBs: return 57
    case .transBsBs: return 58
    case .outMulti: return 59
    case .inpMulti: return 60
    case .overPlacement: return 61
    case .overCom: return 62
    case .overIncome: return 63
    case .optionExpiration: return 64
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_OperationType] = [
    .unspecified,
    .input,
    .bondTax,
    .outputSecurities,
    .overnight,
    .tax,
    .bondRepaymentFull,
    .sellCard,
    .dividendTax,
    .output,
    .bondRepayment,
    .taxCorrection,
    .serviceFee,
    .benefitTax,
    .marginFee,
    .buy,
    .buyCard,
    .inputSecurities,
    .sellMargin,
    .brokerFee,
    .buyMargin,
    .dividend,
    .sell,
    .coupon,
    .successFee,
    .dividendTransfer,
    .accruingVarmargin,
    .writingOffVarmargin,
    .deliveryBuy,
    .deliverySell,
    .trackMfee,
    .trackPfee,
    .taxProgressive,
    .bondTaxProgressive,
    .dividendTaxProgressive,
    .benefitTaxProgressive,
    .taxCorrectionProgressive,
    .taxRepoProgressive,
    .taxRepo,
    .taxRepoHold,
    .taxRepoRefund,
    .taxRepoHoldProgressive,
    .taxRepoRefundProgressive,
    .divExt,
    .taxCorrectionCoupon,
    .cashFee,
    .outFee,
    .outStampDuty,
    .outputSwift,
    .inputSwift,
    .outputAcquiring,
    .inputAcquiring,
    .outputPenalty,
    .adviceFee,
    .transIisBs,
    .transBsBs,
    .outMulti,
    .inpMulti,
    .overPlacement,
    .overCom,
    .overIncome,
    .optionExpiration,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case unspecified // = 0

  ///Успешно.
  case success // = 1

  ///Счёт не найден или недостаточно прав.
  case accountNotFound // = 2

  ///Произошла ошибка.
  case internalError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .accountNotFound
    case 3: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .accountNotFound: return 2
    case .internalError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionStatus] = [
    .unspecified,
    .success,
    .accountNotFound,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum Tinkoff_Public_Invest_Api_Contract_V1_PositionsAccountSubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case positionsSubscriptionStatusUnspecified // = 0

  ///Успешно.
  case positionsSubscriptionStatusSuccess // = 1

  ///Счёт не найден или недостаточно прав.
  case positionsSubscriptionStatusAccountNotFound // = 2

  ///Произошла ошибка.
  case positionsSubscriptionStatusInternalError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .positionsSubscriptionStatusUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .positionsSubscriptionStatusUnspecified
    case 1: self = .positionsSubscriptionStatusSuccess
    case 2: self = .positionsSubscriptionStatusAccountNotFound
    case 3: self = .positionsSubscriptionStatusInternalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .positionsSubscriptionStatusUnspecified: return 0
    case .positionsSubscriptionStatusSuccess: return 1
    case .positionsSubscriptionStatusAccountNotFound: return 2
    case .positionsSubscriptionStatusInternalError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsAccountSubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsAccountSubscriptionStatus] = [
    .positionsSubscriptionStatusUnspecified,
    .positionsSubscriptionStatusSuccess,
    .positionsSubscriptionStatusAccountNotFound,
    .positionsSubscriptionStatusInternalError,
  ]
}

#endif  // swift(>=4.2)

///Запрос получения списка операций по счёту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента.
  public var accountID: String = String()

  ///Начало периода (по UTC).
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода (по UTC).
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Статус запрашиваемых операций.
  public var state: Tinkoff_Public_Invest_Api_Contract_V1_OperationState = .unspecified

  ///Figi-идентификатор инструмента для фильтрации.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список операций.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив операций.
  public var operations: [Tinkoff_Public_Invest_Api_Contract_V1_Operation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по операции.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор операции.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///Идентификатор родительской операции.
  public var parentOperationID: String {
    get {return _storage._parentOperationID}
    set {_uniqueStorage()._parentOperationID = newValue}
  }

  ///Валюта операции.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Сумма операции.
  public var payment: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._payment ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {_uniqueStorage()._payment = nil}

  ///Цена операции за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._price ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  ///Статус операции.
  public var state: Tinkoff_Public_Invest_Api_Contract_V1_OperationState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  ///Количество единиц инструмента.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Неисполненный остаток по сделке.
  public var quantityRest: Int64 {
    get {return _storage._quantityRest}
    set {_uniqueStorage()._quantityRest = newValue}
  }

  ///Figi-идентификатор инструмента, связанного с операцией.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента. Возможные значения: </br>**bond** — облигация; </br>**share** — акция; </br>**currency** — валюта; </br>**etf** — фонд; </br>**futures** — фьючерс.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Дата и время операции в формате часовом поясе UTC.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  ///Текстовое описание типа операции.
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Тип операции.
  public var operationType: Tinkoff_Public_Invest_Api_Contract_V1_OperationType {
    get {return _storage._operationType}
    set {_uniqueStorage()._operationType = newValue}
  }

  ///Массив сделок.
  public var trades: [Tinkoff_Public_Invest_Api_Contract_V1_OperationTrade] {
    get {return _storage._trades}
    set {_uniqueStorage()._trades = newValue}
  }

  ///Идентификатор актива
  public var assetUid: String {
    get {return _storage._assetUid}
    set {_uniqueStorage()._assetUid = newValue}
  }

  ///position_uid-идентификатора инструмента.
  public var positionUid: String {
    get {return _storage._positionUid}
    set {_uniqueStorage()._positionUid = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Сделка по операции.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OperationTrade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор сделки.
  public var tradeID: String = String()

  ///Дата и время сделки в часовом поясе UTC.
  public var dateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  public var hasDateTime: Bool {return self._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  public mutating func clearDateTime() {self._dateTime = nil}

  ///Количество инструментов.
  public var quantity: Int64 = 0

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
}

///Запрос получения текущего портфеля по счёту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя.
  public var accountID: String = String()

  ///Валюта, в которой требуется рассчитать портфель
  public var currency: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest.CurrencyRequest = .rub

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CurrencyRequest: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    ///Рубли
    case rub // = 0

    ///Доллары
    case usd // = 1

    ///Евро
    case eur // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .rub
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .rub
      case 1: self = .usd
      case 2: self = .eur
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .rub: return 0
      case .usd: return 1
      case .eur: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest.CurrencyRequest: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest.CurrencyRequest] = [
    .rub,
    .usd,
    .eur,
  ]
}

#endif  // swift(>=4.2)

///Текущий портфель по счёту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Общая стоимость акций в портфеле.
  public var totalAmountShares: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountShares ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountShares = newValue}
  }
  /// Returns true if `totalAmountShares` has been explicitly set.
  public var hasTotalAmountShares: Bool {return _storage._totalAmountShares != nil}
  /// Clears the value of `totalAmountShares`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountShares() {_uniqueStorage()._totalAmountShares = nil}

  ///Общая стоимость облигаций в портфеле.
  public var totalAmountBonds: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountBonds ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountBonds = newValue}
  }
  /// Returns true if `totalAmountBonds` has been explicitly set.
  public var hasTotalAmountBonds: Bool {return _storage._totalAmountBonds != nil}
  /// Clears the value of `totalAmountBonds`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountBonds() {_uniqueStorage()._totalAmountBonds = nil}

  ///Общая стоимость фондов в портфеле.
  public var totalAmountEtf: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountEtf ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountEtf = newValue}
  }
  /// Returns true if `totalAmountEtf` has been explicitly set.
  public var hasTotalAmountEtf: Bool {return _storage._totalAmountEtf != nil}
  /// Clears the value of `totalAmountEtf`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountEtf() {_uniqueStorage()._totalAmountEtf = nil}

  ///Общая стоимость валют в портфеле.
  public var totalAmountCurrencies: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountCurrencies ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountCurrencies = newValue}
  }
  /// Returns true if `totalAmountCurrencies` has been explicitly set.
  public var hasTotalAmountCurrencies: Bool {return _storage._totalAmountCurrencies != nil}
  /// Clears the value of `totalAmountCurrencies`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountCurrencies() {_uniqueStorage()._totalAmountCurrencies = nil}

  ///Общая стоимость фьючерсов в портфеле.
  public var totalAmountFutures: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountFutures ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountFutures = newValue}
  }
  /// Returns true if `totalAmountFutures` has been explicitly set.
  public var hasTotalAmountFutures: Bool {return _storage._totalAmountFutures != nil}
  /// Clears the value of `totalAmountFutures`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountFutures() {_uniqueStorage()._totalAmountFutures = nil}

  ///Текущая относительная доходность портфеля, в %.
  public var expectedYield: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._expectedYield ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._expectedYield = newValue}
  }
  /// Returns true if `expectedYield` has been explicitly set.
  public var hasExpectedYield: Bool {return _storage._expectedYield != nil}
  /// Clears the value of `expectedYield`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYield() {_uniqueStorage()._expectedYield = nil}

  ///Список позиций портфеля.
  public var positions: [Tinkoff_Public_Invest_Api_Contract_V1_PortfolioPosition] {
    get {return _storage._positions}
    set {_uniqueStorage()._positions = newValue}
  }

  ///Идентификатор счёта пользователя.
  public var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  ///Общая стоимость опционов в портфеле.
  public var totalAmountOptions: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountOptions ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountOptions = newValue}
  }
  /// Returns true if `totalAmountOptions` has been explicitly set.
  public var hasTotalAmountOptions: Bool {return _storage._totalAmountOptions != nil}
  /// Clears the value of `totalAmountOptions`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountOptions() {_uniqueStorage()._totalAmountOptions = nil}

  ///Общая стоимость структурных нот в портфеле.
  public var totalAmountSp: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountSp ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountSp = newValue}
  }
  /// Returns true if `totalAmountSp` has been explicitly set.
  public var hasTotalAmountSp: Bool {return _storage._totalAmountSp != nil}
  /// Clears the value of `totalAmountSp`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountSp() {_uniqueStorage()._totalAmountSp = nil}

  ///Общая стоимость портфеля.
  public var totalAmountPortfolio: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalAmountPortfolio ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalAmountPortfolio = newValue}
  }
  /// Returns true if `totalAmountPortfolio` has been explicitly set.
  public var hasTotalAmountPortfolio: Bool {return _storage._totalAmountPortfolio != nil}
  /// Clears the value of `totalAmountPortfolio`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountPortfolio() {_uniqueStorage()._totalAmountPortfolio = nil}

  ///Массив виртуальных позиций портфеля.
  public var virtualPositions: [Tinkoff_Public_Invest_Api_Contract_V1_VirtualPortfolioPosition] {
    get {return _storage._virtualPositions}
    set {_uniqueStorage()._virtualPositions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос позиций портфеля по счёту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя.
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список позиций по счёту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валютных позиций портфеля.
  public var money: [Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue] = []

  ///Массив заблокированных валютных позиций портфеля.
  public var blocked: [Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue] = []

  ///Список ценно-бумажных позиций портфеля.
  public var securities: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsSecurities] = []

  ///Признак идущей в данный момент выгрузки лимитов.
  public var limitsLoadingInProgress: Bool = false

  ///Список фьючерсов портфеля.
  public var futures: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsFutures] = []

  ///Список опционов портфеля.
  public var options: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsOptions] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос доступного для вывода остатка.
public struct Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя.
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Доступный для вывода остаток.
public struct Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валютных позиций портфеля.
  public var money: [Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue] = []

  ///Массив заблокированных валютных позиций портфеля.
  public var blocked: [Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue] = []

  ///Заблокировано под гарантийное обеспечение фьючерсов.
  public var blockedGuarantee: [Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Позиции портфеля.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PortfolioPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатора инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Количество инструмента в портфеле в штуках.
  public var quantity: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._quantity ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._quantity = newValue}
  }
  /// Returns true if `quantity` has been explicitly set.
  public var hasQuantity: Bool {return _storage._quantity != nil}
  /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
  public mutating func clearQuantity() {_uniqueStorage()._quantity = nil}

  ///Средневзвешенная цена позиции. **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._averagePositionPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._averagePositionPrice = newValue}
  }
  /// Returns true if `averagePositionPrice` has been explicitly set.
  public var hasAveragePositionPrice: Bool {return _storage._averagePositionPrice != nil}
  /// Clears the value of `averagePositionPrice`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPrice() {_uniqueStorage()._averagePositionPrice = nil}

  ///Текущая рассчитанная доходность позиции.
  public var expectedYield: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._expectedYield ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._expectedYield = newValue}
  }
  /// Returns true if `expectedYield` has been explicitly set.
  public var hasExpectedYield: Bool {return _storage._expectedYield != nil}
  /// Clears the value of `expectedYield`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYield() {_uniqueStorage()._expectedYield = nil}

  /// Текущий НКД.
  public var currentNkd: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._currentNkd ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._currentNkd = newValue}
  }
  /// Returns true if `currentNkd` has been explicitly set.
  public var hasCurrentNkd: Bool {return _storage._currentNkd != nil}
  /// Clears the value of `currentNkd`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentNkd() {_uniqueStorage()._currentNkd = nil}

  /// Deprecated Средняя цена позиции в пунктах (для фьючерсов). **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPricePt: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._averagePositionPricePt ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._averagePositionPricePt = newValue}
  }
  /// Returns true if `averagePositionPricePt` has been explicitly set.
  public var hasAveragePositionPricePt: Bool {return _storage._averagePositionPricePt != nil}
  /// Clears the value of `averagePositionPricePt`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPricePt() {_uniqueStorage()._averagePositionPricePt = nil}

  ///Текущая цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var currentPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._currentPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._currentPrice = newValue}
  }
  /// Returns true if `currentPrice` has been explicitly set.
  public var hasCurrentPrice: Bool {return _storage._currentPrice != nil}
  /// Clears the value of `currentPrice`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPrice() {_uniqueStorage()._currentPrice = nil}

  ///Средняя цена позиции по методу FIFO. **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPriceFifo: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._averagePositionPriceFifo ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._averagePositionPriceFifo = newValue}
  }
  /// Returns true if `averagePositionPriceFifo` has been explicitly set.
  public var hasAveragePositionPriceFifo: Bool {return _storage._averagePositionPriceFifo != nil}
  /// Clears the value of `averagePositionPriceFifo`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPriceFifo() {_uniqueStorage()._averagePositionPriceFifo = nil}

  ///Deprecated Количество лотов в портфеле.
  public var quantityLots: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._quantityLots ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._quantityLots = newValue}
  }
  /// Returns true if `quantityLots` has been explicitly set.
  public var hasQuantityLots: Bool {return _storage._quantityLots != nil}
  /// Clears the value of `quantityLots`. Subsequent reads from it will return its default value.
  public mutating func clearQuantityLots() {_uniqueStorage()._quantityLots = nil}

  ///Заблокировано на бирже.
  public var blocked: Bool {
    get {return _storage._blocked}
    set {_uniqueStorage()._blocked = newValue}
  }

  ///Количество бумаг, заблокированных выставленными заявками.
  public var blockedLots: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._blockedLots ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._blockedLots = newValue}
  }
  /// Returns true if `blockedLots` has been explicitly set.
  public var hasBlockedLots: Bool {return _storage._blockedLots != nil}
  /// Clears the value of `blockedLots`. Subsequent reads from it will return its default value.
  public mutating func clearBlockedLots() {_uniqueStorage()._blockedLots = nil}

  ///position_uid-идентификатора инструмента
  public var positionUid: String {
    get {return _storage._positionUid}
    set {_uniqueStorage()._positionUid = newValue}
  }

  ///instrument_uid-идентификатора инструмента
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  ///Вариационная маржа
  public var varMargin: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._varMargin ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._varMargin = newValue}
  }
  /// Returns true if `varMargin` has been explicitly set.
  public var hasVarMargin: Bool {return _storage._varMargin != nil}
  /// Clears the value of `varMargin`. Subsequent reads from it will return its default value.
  public mutating func clearVarMargin() {_uniqueStorage()._varMargin = nil}

  ///Текущая рассчитанная доходность позиции.
  public var expectedYieldFifo: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._expectedYieldFifo ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._expectedYieldFifo = newValue}
  }
  /// Returns true if `expectedYieldFifo` has been explicitly set.
  public var hasExpectedYieldFifo: Bool {return _storage._expectedYieldFifo != nil}
  /// Clears the value of `expectedYieldFifo`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYieldFifo() {_uniqueStorage()._expectedYieldFifo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_VirtualPortfolioPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///position_uid-идентификатора инструмента
  public var positionUid: String {
    get {return _storage._positionUid}
    set {_uniqueStorage()._positionUid = newValue}
  }

  ///instrument_uid-идентификатора инструмента
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  ///Figi-идентификатора инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Количество инструмента в портфеле в штуках.
  public var quantity: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._quantity ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._quantity = newValue}
  }
  /// Returns true if `quantity` has been explicitly set.
  public var hasQuantity: Bool {return _storage._quantity != nil}
  /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
  public mutating func clearQuantity() {_uniqueStorage()._quantity = nil}

  ///Средневзвешенная цена позиции. **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._averagePositionPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._averagePositionPrice = newValue}
  }
  /// Returns true if `averagePositionPrice` has been explicitly set.
  public var hasAveragePositionPrice: Bool {return _storage._averagePositionPrice != nil}
  /// Clears the value of `averagePositionPrice`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPrice() {_uniqueStorage()._averagePositionPrice = nil}

  ///Текущая рассчитанная доходность позиции.
  public var expectedYield: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._expectedYield ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._expectedYield = newValue}
  }
  /// Returns true if `expectedYield` has been explicitly set.
  public var hasExpectedYield: Bool {return _storage._expectedYield != nil}
  /// Clears the value of `expectedYield`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYield() {_uniqueStorage()._expectedYield = nil}

  ///Текущая рассчитанная доходность позиции.
  public var expectedYieldFifo: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._expectedYieldFifo ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._expectedYieldFifo = newValue}
  }
  /// Returns true if `expectedYieldFifo` has been explicitly set.
  public var hasExpectedYieldFifo: Bool {return _storage._expectedYieldFifo != nil}
  /// Clears the value of `expectedYieldFifo`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYieldFifo() {_uniqueStorage()._expectedYieldFifo = nil}

  ///Дата до которой нужно продать виртуальные бумаги, после этой даты виртуальная позиция "сгорит"
  public var expireDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expireDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expireDate = newValue}
  }
  /// Returns true if `expireDate` has been explicitly set.
  public var hasExpireDate: Bool {return _storage._expireDate != nil}
  /// Clears the value of `expireDate`. Subsequent reads from it will return its default value.
  public mutating func clearExpireDate() {_uniqueStorage()._expireDate = nil}

  ///Текущая цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var currentPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._currentPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._currentPrice = newValue}
  }
  /// Returns true if `currentPrice` has been explicitly set.
  public var hasCurrentPrice: Bool {return _storage._currentPrice != nil}
  /// Clears the value of `currentPrice`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPrice() {_uniqueStorage()._currentPrice = nil}

  ///Средняя цена позиции по методу FIFO. **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPriceFifo: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._averagePositionPriceFifo ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._averagePositionPriceFifo = newValue}
  }
  /// Returns true if `averagePositionPriceFifo` has been explicitly set.
  public var hasAveragePositionPriceFifo: Bool {return _storage._averagePositionPriceFifo != nil}
  /// Clears the value of `averagePositionPriceFifo`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPriceFifo() {_uniqueStorage()._averagePositionPriceFifo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Баланс позиции ценной бумаги.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsSecurities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор бумаги.
  public var figi: String = String()

  ///Количество бумаг заблокированных выставленными заявками.
  public var blocked: Int64 = 0

  ///Текущий незаблокированный баланс.
  public var balance: Int64 = 0

  ///Уникальный идентификатор позиции.
  public var positionUid: String = String()

  ///Уникальный идентификатор  инструмента.
  public var instrumentUid: String = String()

  ///Заблокировано на бирже.
  public var exchangeBlocked: Bool = false

  ///Тип инструмента.
  public var instrumentType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Баланс фьючерса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsFutures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор фьючерса.
  public var figi: String = String()

  ///Количество бумаг заблокированных выставленными заявками.
  public var blocked: Int64 = 0

  ///Текущий незаблокированный баланс.
  public var balance: Int64 = 0

  ///Уникальный идентификатор позиции.
  public var positionUid: String = String()

  ///Уникальный идентификатор  инструмента.
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Баланс опциона.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор позиции опциона.
  public var positionUid: String = String()

  ///Уникальный идентификатор  инструмента.
  public var instrumentUid: String = String()

  ///Количество бумаг заблокированных выставленными заявками.
  public var blocked: Int64 = 0

  ///Текущий незаблокированный баланс.
  public var balance: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest.OneOf_Payload? = nil

  public var generateBrokerReportRequest: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest {
    get {
      if case .generateBrokerReportRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest()
    }
    set {payload = .generateBrokerReportRequest(newValue)}
  }

  public var getBrokerReportRequest: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest {
    get {
      if case .getBrokerReportRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest()
    }
    set {payload = .getBrokerReportRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case generateBrokerReportRequest(Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest)
    case getBrokerReportRequest(Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateBrokerReportRequest, .generateBrokerReportRequest): return {
        guard case .generateBrokerReportRequest(let l) = lhs, case .generateBrokerReportRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBrokerReportRequest, .getBrokerReportRequest): return {
        guard case .getBrokerReportRequest(let l) = lhs, case .getBrokerReportRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse.OneOf_Payload? = nil

  public var generateBrokerReportResponse: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse {
    get {
      if case .generateBrokerReportResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse()
    }
    set {payload = .generateBrokerReportResponse(newValue)}
  }

  public var getBrokerReportResponse: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse {
    get {
      if case .getBrokerReportResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse()
    }
    set {payload = .getBrokerReportResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case generateBrokerReportResponse(Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse)
    case getBrokerReportResponse(Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateBrokerReportResponse, .generateBrokerReportResponse): return {
        guard case .generateBrokerReportResponse(let l) = lhs, case .generateBrokerReportResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBrokerReportResponse, .getBrokerReportResponse): return {
        guard case .getBrokerReportResponse(let l) = lhs, case .getBrokerReportResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента.
  public var accountID: String = String()

  ///Начало периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования брокерского отчёта.
  public var taskID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования брокерского отчёта.
  public var taskID: String = String()

  ///Номер страницы отчета (начинается с 1), значение по умолчанию: 0.
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var brokerReport: [Tinkoff_Public_Invest_Api_Contract_V1_BrokerReport] = []

  ///Количество записей в отчете.
  public var itemsCount: Int32 = 0

  ///Количество страниц с данными отчета (начинается с 0).
  public var pagesCount: Int32 = 0

  ///Текущая страница (начинается с 0).
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_BrokerReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Номер сделки.
  public var tradeID: String {
    get {return _storage._tradeID}
    set {_uniqueStorage()._tradeID = newValue}
  }

  ///Номер поручения.
  public var orderID: String {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Признак исполнения.
  public var executeSign: String {
    get {return _storage._executeSign}
    set {_uniqueStorage()._executeSign = newValue}
  }

  ///Дата и время заключения в часовом поясе UTC.
  public var tradeDatetime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._tradeDatetime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._tradeDatetime = newValue}
  }
  /// Returns true if `tradeDatetime` has been explicitly set.
  public var hasTradeDatetime: Bool {return _storage._tradeDatetime != nil}
  /// Clears the value of `tradeDatetime`. Subsequent reads from it will return its default value.
  public mutating func clearTradeDatetime() {_uniqueStorage()._tradeDatetime = nil}

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Режим торгов.
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Вид сделки.
  public var direction: String {
    get {return _storage._direction}
    set {_uniqueStorage()._direction = newValue}
  }

  ///Сокращённое наименование актива.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Код актива.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Цена за единицу.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._price ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  ///Количество.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Сумма (без НКД).
  public var orderAmount: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._orderAmount ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._orderAmount = newValue}
  }
  /// Returns true if `orderAmount` has been explicitly set.
  public var hasOrderAmount: Bool {return _storage._orderAmount != nil}
  /// Clears the value of `orderAmount`. Subsequent reads from it will return its default value.
  public mutating func clearOrderAmount() {_uniqueStorage()._orderAmount = nil}

  ///НКД.
  public var aciValue: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._aciValue ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._aciValue = newValue}
  }
  /// Returns true if `aciValue` has been explicitly set.
  public var hasAciValue: Bool {return _storage._aciValue != nil}
  /// Clears the value of `aciValue`. Subsequent reads from it will return its default value.
  public mutating func clearAciValue() {_uniqueStorage()._aciValue = nil}

  ///Сумма сделки.
  public var totalOrderAmount: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._totalOrderAmount ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._totalOrderAmount = newValue}
  }
  /// Returns true if `totalOrderAmount` has been explicitly set.
  public var hasTotalOrderAmount: Bool {return _storage._totalOrderAmount != nil}
  /// Clears the value of `totalOrderAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTotalOrderAmount() {_uniqueStorage()._totalOrderAmount = nil}

  ///Комиссия брокера.
  public var brokerCommission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._brokerCommission ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._brokerCommission = newValue}
  }
  /// Returns true if `brokerCommission` has been explicitly set.
  public var hasBrokerCommission: Bool {return _storage._brokerCommission != nil}
  /// Clears the value of `brokerCommission`. Subsequent reads from it will return its default value.
  public mutating func clearBrokerCommission() {_uniqueStorage()._brokerCommission = nil}

  ///Комиссия биржи.
  public var exchangeCommission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._exchangeCommission ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._exchangeCommission = newValue}
  }
  /// Returns true if `exchangeCommission` has been explicitly set.
  public var hasExchangeCommission: Bool {return _storage._exchangeCommission != nil}
  /// Clears the value of `exchangeCommission`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeCommission() {_uniqueStorage()._exchangeCommission = nil}

  ///Комиссия клир. центра.
  public var exchangeClearingCommission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._exchangeClearingCommission ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._exchangeClearingCommission = newValue}
  }
  /// Returns true if `exchangeClearingCommission` has been explicitly set.
  public var hasExchangeClearingCommission: Bool {return _storage._exchangeClearingCommission != nil}
  /// Clears the value of `exchangeClearingCommission`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeClearingCommission() {_uniqueStorage()._exchangeClearingCommission = nil}

  ///Ставка РЕПО (%).
  public var repoRate: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._repoRate ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._repoRate = newValue}
  }
  /// Returns true if `repoRate` has been explicitly set.
  public var hasRepoRate: Bool {return _storage._repoRate != nil}
  /// Clears the value of `repoRate`. Subsequent reads from it will return its default value.
  public mutating func clearRepoRate() {_uniqueStorage()._repoRate = nil}

  ///Контрагент/Брокер.
  public var party: String {
    get {return _storage._party}
    set {_uniqueStorage()._party = newValue}
  }

  ///Дата расчётов в часовом поясе UTC.
  public var clearValueDate_p: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._clearValueDate_p ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._clearValueDate_p = newValue}
  }
  /// Returns true if `clearValueDate_p` has been explicitly set.
  public var hasClearValueDate_p: Bool {return _storage._clearValueDate_p != nil}
  /// Clears the value of `clearValueDate_p`. Subsequent reads from it will return its default value.
  public mutating func clearClearValueDate_p() {_uniqueStorage()._clearValueDate_p = nil}

  ///Дата поставки в часовом поясе UTC.
  public var secValueDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._secValueDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._secValueDate = newValue}
  }
  /// Returns true if `secValueDate` has been explicitly set.
  public var hasSecValueDate: Bool {return _storage._secValueDate != nil}
  /// Clears the value of `secValueDate`. Subsequent reads from it will return its default value.
  public mutating func clearSecValueDate() {_uniqueStorage()._secValueDate = nil}

  ///Статус брокера.
  public var brokerStatus: String {
    get {return _storage._brokerStatus}
    set {_uniqueStorage()._brokerStatus = newValue}
  }

  ///Тип дог.
  public var separateAgreementType: String {
    get {return _storage._separateAgreementType}
    set {_uniqueStorage()._separateAgreementType = newValue}
  }

  ///Номер дог.
  public var separateAgreementNumber: String {
    get {return _storage._separateAgreementNumber}
    set {_uniqueStorage()._separateAgreementNumber = newValue}
  }

  ///Дата дог.
  public var separateAgreementDate: String {
    get {return _storage._separateAgreementDate}
    set {_uniqueStorage()._separateAgreementDate = newValue}
  }

  ///Тип расчёта по сделке.
  public var deliveryType: String {
    get {return _storage._deliveryType}
    set {_uniqueStorage()._deliveryType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest.OneOf_Payload? = nil

  ///Объект запроса формирования отчёта.
  public var generateDivForeignIssuerReport: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest {
    get {
      if case .generateDivForeignIssuerReport(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest()
    }
    set {payload = .generateDivForeignIssuerReport(newValue)}
  }

  ///Объект запроса сформированного отчёта.
  public var getDivForeignIssuerReport: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest {
    get {
      if case .getDivForeignIssuerReport(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest()
    }
    set {payload = .getDivForeignIssuerReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект запроса формирования отчёта.
    case generateDivForeignIssuerReport(Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest)
    ///Объект запроса сформированного отчёта.
    case getDivForeignIssuerReport(Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateDivForeignIssuerReport, .generateDivForeignIssuerReport): return {
        guard case .generateDivForeignIssuerReport(let l) = lhs, case .generateDivForeignIssuerReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getDivForeignIssuerReport, .getDivForeignIssuerReport): return {
        guard case .getDivForeignIssuerReport(let l) = lhs, case .getDivForeignIssuerReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse.OneOf_Payload? = nil

  ///Объект результата задачи запуска формирования отчёта.
  public var generateDivForeignIssuerReportResponse: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse {
    get {
      if case .generateDivForeignIssuerReportResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse()
    }
    set {payload = .generateDivForeignIssuerReportResponse(newValue)}
  }

  ///Отчёт "Справка о доходах за пределами РФ".
  public var divForeignIssuerReport: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse {
    get {
      if case .divForeignIssuerReport(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse()
    }
    set {payload = .divForeignIssuerReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект результата задачи запуска формирования отчёта.
    case generateDivForeignIssuerReportResponse(Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse)
    ///Отчёт "Справка о доходах за пределами РФ".
    case divForeignIssuerReport(Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateDivForeignIssuerReportResponse, .generateDivForeignIssuerReportResponse): return {
        guard case .generateDivForeignIssuerReportResponse(let l) = lhs, case .generateDivForeignIssuerReportResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.divForeignIssuerReport, .divForeignIssuerReport): return {
        guard case .divForeignIssuerReport(let l) = lhs, case .divForeignIssuerReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Объект запроса формирования отчёта "Справка о доходах за пределами РФ".
public struct Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента.
  public var accountID: String = String()

  ///Начало периода (по UTC).
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода (по UTC).
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Объект запроса сформированного отчёта "Справка о доходах за пределами РФ".
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования отчёта.
  public var taskID: String = String()

  ///Номер страницы отчета (начинается с 0), значение по умолчанию: 0.
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Объект результата задачи запуска формирования отчёта "Справка о доходах за пределами РФ".
public struct Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования отчёта.
  public var taskID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dividendsForeignIssuerReport: [Tinkoff_Public_Invest_Api_Contract_V1_DividendsForeignIssuerReport] = []

  ///Количество записей в отчете.
  public var itemsCount: Int32 = 0

  ///Количество страниц с данными отчета (начинается с 0).
  public var pagesCount: Int32 = 0

  ///Текущая страница (начинается с 0).
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Отчёт "Справка о доходах за пределами РФ".
public struct Tinkoff_Public_Invest_Api_Contract_V1_DividendsForeignIssuerReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Дата фиксации реестра.
  public var recordDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._recordDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._recordDate = newValue}
  }
  /// Returns true if `recordDate` has been explicitly set.
  public var hasRecordDate: Bool {return _storage._recordDate != nil}
  /// Clears the value of `recordDate`. Subsequent reads from it will return its default value.
  public mutating func clearRecordDate() {_uniqueStorage()._recordDate = nil}

  ///Дата выплаты.
  public var paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._paymentDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._paymentDate = newValue}
  }
  /// Returns true if `paymentDate` has been explicitly set.
  public var hasPaymentDate: Bool {return _storage._paymentDate != nil}
  /// Clears the value of `paymentDate`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentDate() {_uniqueStorage()._paymentDate = nil}

  ///Наименование ценной бумаги.
  public var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  ///ISIN-идентификатор ценной бумаги.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Страна эмитента. Для депозитарных расписок указывается страна эмитента базового актива.
  public var issuerCountry: String {
    get {return _storage._issuerCountry}
    set {_uniqueStorage()._issuerCountry = newValue}
  }

  ///Количество ценных бумаг.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Выплаты на одну бумагу
  public var dividend: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dividend ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dividend = newValue}
  }
  /// Returns true if `dividend` has been explicitly set.
  public var hasDividend: Bool {return _storage._dividend != nil}
  /// Clears the value of `dividend`. Subsequent reads from it will return its default value.
  public mutating func clearDividend() {_uniqueStorage()._dividend = nil}

  ///Комиссия внешних платёжных агентов.
  public var externalCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._externalCommission ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._externalCommission = newValue}
  }
  /// Returns true if `externalCommission` has been explicitly set.
  public var hasExternalCommission: Bool {return _storage._externalCommission != nil}
  /// Clears the value of `externalCommission`. Subsequent reads from it will return its default value.
  public mutating func clearExternalCommission() {_uniqueStorage()._externalCommission = nil}

  ///Сумма до удержания налога.
  public var dividendGross: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dividendGross ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dividendGross = newValue}
  }
  /// Returns true if `dividendGross` has been explicitly set.
  public var hasDividendGross: Bool {return _storage._dividendGross != nil}
  /// Clears the value of `dividendGross`. Subsequent reads from it will return its default value.
  public mutating func clearDividendGross() {_uniqueStorage()._dividendGross = nil}

  ///Сумма налога, удержанного агентом.
  public var tax: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._tax ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._tax = newValue}
  }
  /// Returns true if `tax` has been explicitly set.
  public var hasTax: Bool {return _storage._tax != nil}
  /// Clears the value of `tax`. Subsequent reads from it will return its default value.
  public mutating func clearTax() {_uniqueStorage()._tax = nil}

  ///Итоговая сумма выплаты.
  public var dividendAmount: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dividendAmount ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dividendAmount = newValue}
  }
  /// Returns true if `dividendAmount` has been explicitly set.
  public var hasDividendAmount: Bool {return _storage._dividendAmount != nil}
  /// Clears the value of `dividendAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDividendAmount() {_uniqueStorage()._dividendAmount = nil}

  ///Валюта.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос установки stream-соединения.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив идентификаторов счётов пользователя
  public var accounts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация по позициям и доходностям портфелей.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse.OneOf_Payload? = nil

  ///Объект результата подписки.
  public var subscriptions: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult {
    get {
      if case .subscriptions(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult()
    }
    set {payload = .subscriptions(newValue)}
  }

  ///Объект стриминга портфеля.
  public var portfolio: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse {
    get {
      if case .portfolio(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse()
    }
    set {payload = .portfolio(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Tinkoff_Public_Invest_Api_Contract_V1_Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Ping()
    }
    set {payload = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект результата подписки.
    case subscriptions(Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult)
    ///Объект стриминга портфеля.
    case portfolio(Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse)
    ///Проверка активности стрима.
    case ping(Tinkoff_Public_Invest_Api_Contract_V1_Ping)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscriptions, .subscriptions): return {
        guard case .subscriptions(let l) = lhs, case .subscriptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.portfolio, .portfolio): return {
        guard case .portfolio(let l) = lhs, case .portfolio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Объект результата подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив счетов клиента.
  public var accounts: [Tinkoff_Public_Invest_Api_Contract_V1_AccountSubscriptionStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Счет клиента.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AccountSubscriptionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта
  public var accountID: String = String()

  ///Результат подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос списка операций по счёту с пагинацией.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента. Обязательный параметр для данного метода, остальные параметры опциональны.
  public var accountID: String = String()

  ///Идентификатор инструмента (Figi инструмента или uid инструмента)
  public var instrumentID: String = String()

  ///Начало периода (по UTC).
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода (по UTC).
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Идентификатор элемента, с которого начать формировать ответ.
  public var cursor: String = String()

  ///Лимит количества операций. По умолчанию устанавливается значение **100**, максимальное значение 1000.
  public var limit: Int32 = 0

  ///Тип операции. Принимает значение из списка OperationType.
  public var operationTypes: [Tinkoff_Public_Invest_Api_Contract_V1_OperationType] = []

  ///Статус запрашиваемых операций, возможные значения указаны в OperationState.
  public var state: Tinkoff_Public_Invest_Api_Contract_V1_OperationState = .unspecified

  ///Флаг возвращать ли комиссии, по умолчанию false
  public var withoutCommissions: Bool = false

  ///Флаг получения ответа без массива сделок.
  public var withoutTrades: Bool = false

  ///Флаг не показывать overnight операций.
  public var withoutOvernights: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список операций по счёту с пагинацией.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Признак, есть ли следующий элемент.
  public var hasNext_p: Bool = false

  ///Следующий курсор.
  public var nextCursor: String = String()

  ///Список операций.
  public var items: [Tinkoff_Public_Invest_Api_Contract_V1_OperationItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные об операции.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OperationItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Курсор.
  public var cursor: String {
    get {return _storage._cursor}
    set {_uniqueStorage()._cursor = newValue}
  }

  ///Номер счета клиента.
  public var brokerAccountID: String {
    get {return _storage._brokerAccountID}
    set {_uniqueStorage()._brokerAccountID = newValue}
  }

  ///Идентификатор операции, может меняться с течением времени.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///Идентификатор родительской операции, может измениться, если изменился id родительской операции.
  public var parentOperationID: String {
    get {return _storage._parentOperationID}
    set {_uniqueStorage()._parentOperationID = newValue}
  }

  ///Название операции.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Дата поручения.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  ///Тип операции.
  public var type: Tinkoff_Public_Invest_Api_Contract_V1_OperationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Описание операции.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  ///Статус поручения.
  public var state: Tinkoff_Public_Invest_Api_Contract_V1_OperationState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  ///Figi.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Тип инструмента.
  public var instrumentKind: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentType {
    get {return _storage._instrumentKind}
    set {_uniqueStorage()._instrumentKind = newValue}
  }

  ///position_uid-идентификатора инструмента.
  public var positionUid: String {
    get {return _storage._positionUid}
    set {_uniqueStorage()._positionUid = newValue}
  }

  ///Сумма операции.
  public var payment: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._payment ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {_uniqueStorage()._payment = nil}

  ///Цена операции за 1 инструмент.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._price ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  ///Комиссия.
  public var commission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._commission ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._commission = newValue}
  }
  /// Returns true if `commission` has been explicitly set.
  public var hasCommission: Bool {return _storage._commission != nil}
  /// Clears the value of `commission`. Subsequent reads from it will return its default value.
  public mutating func clearCommission() {_uniqueStorage()._commission = nil}

  ///Доходность.
  public var yield: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._yield ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._yield = newValue}
  }
  /// Returns true if `yield` has been explicitly set.
  public var hasYield: Bool {return _storage._yield != nil}
  /// Clears the value of `yield`. Subsequent reads from it will return its default value.
  public mutating func clearYield() {_uniqueStorage()._yield = nil}

  ///Относительная доходность.
  public var yieldRelative: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._yieldRelative ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._yieldRelative = newValue}
  }
  /// Returns true if `yieldRelative` has been explicitly set.
  public var hasYieldRelative: Bool {return _storage._yieldRelative != nil}
  /// Clears the value of `yieldRelative`. Subsequent reads from it will return its default value.
  public mutating func clearYieldRelative() {_uniqueStorage()._yieldRelative = nil}

  ///Накопленный купонный доход.
  public var accruedInt: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._accruedInt ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._accruedInt = newValue}
  }
  /// Returns true if `accruedInt` has been explicitly set.
  public var hasAccruedInt: Bool {return _storage._accruedInt != nil}
  /// Clears the value of `accruedInt`. Subsequent reads from it will return its default value.
  public mutating func clearAccruedInt() {_uniqueStorage()._accruedInt = nil}

  ///Количество единиц инструмента.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Неисполненный остаток по сделке.
  public var quantityRest: Int64 {
    get {return _storage._quantityRest}
    set {_uniqueStorage()._quantityRest = newValue}
  }

  ///Исполненный остаток.
  public var quantityDone: Int64 {
    get {return _storage._quantityDone}
    set {_uniqueStorage()._quantityDone = newValue}
  }

  ///Дата и время снятия заявки.
  public var cancelDateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._cancelDateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._cancelDateTime = newValue}
  }
  /// Returns true if `cancelDateTime` has been explicitly set.
  public var hasCancelDateTime: Bool {return _storage._cancelDateTime != nil}
  /// Clears the value of `cancelDateTime`. Subsequent reads from it will return its default value.
  public mutating func clearCancelDateTime() {_uniqueStorage()._cancelDateTime = nil}

  ///Причина отмены операции.
  public var cancelReason: String {
    get {return _storage._cancelReason}
    set {_uniqueStorage()._cancelReason = newValue}
  }

  ///Массив сделок.
  public var tradesInfo: Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades {
    get {return _storage._tradesInfo ?? Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades()}
    set {_uniqueStorage()._tradesInfo = newValue}
  }
  /// Returns true if `tradesInfo` has been explicitly set.
  public var hasTradesInfo: Bool {return _storage._tradesInfo != nil}
  /// Clears the value of `tradesInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTradesInfo() {_uniqueStorage()._tradesInfo = nil}

  ///Идентификатор актива
  public var assetUid: String {
    get {return _storage._assetUid}
    set {_uniqueStorage()._assetUid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Массив с информацией о сделках.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trades: [Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrade] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Сделка по операции.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Номер сделки
  public var num: String = String()

  ///Дата сделки
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  ///Количество в единицах.
  public var quantity: Int64 = 0

  ///Цена.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Доходность.
  public var yield: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _yield ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_yield = newValue}
  }
  /// Returns true if `yield` has been explicitly set.
  public var hasYield: Bool {return self._yield != nil}
  /// Clears the value of `yield`. Subsequent reads from it will return its default value.
  public mutating func clearYield() {self._yield = nil}

  ///Относительная доходность.
  public var yieldRelative: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _yieldRelative ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_yieldRelative = newValue}
  }
  /// Returns true if `yieldRelative` has been explicitly set.
  public var hasYieldRelative: Bool {return self._yieldRelative != nil}
  /// Clears the value of `yieldRelative`. Subsequent reads from it will return its default value.
  public mutating func clearYieldRelative() {self._yieldRelative = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
  fileprivate var _yield: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
  fileprivate var _yieldRelative: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Запрос установки stream-соединения позиций.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив идентификаторов счётов пользователя
  public var accounts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация по изменению позиций портфеля.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse.OneOf_Payload? = nil

  ///Объект результата подписки.
  public var subscriptions: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult {
    get {
      if case .subscriptions(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult()
    }
    set {payload = .subscriptions(newValue)}
  }

  ///Объект стриминга позиций.
  public var position: Tinkoff_Public_Invest_Api_Contract_V1_PositionData {
    get {
      if case .position(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_PositionData()
    }
    set {payload = .position(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Tinkoff_Public_Invest_Api_Contract_V1_Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Ping()
    }
    set {payload = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект результата подписки.
    case subscriptions(Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult)
    ///Объект стриминга позиций.
    case position(Tinkoff_Public_Invest_Api_Contract_V1_PositionData)
    ///Проверка активности стрима.
    case ping(Tinkoff_Public_Invest_Api_Contract_V1_Ping)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscriptions, .subscriptions): return {
        guard case .subscriptions(let l) = lhs, case .subscriptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.position, .position): return {
        guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Объект результата подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив счетов клиента.
  public var accounts: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Счет клиента.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта
  public var accountID: String = String()

  ///Результат подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_PositionsAccountSubscriptionStatus = .positionsSubscriptionStatusUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные о позиции портфеля.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта.
  public var accountID: String = String()

  ///Массив валютных позиций портфеля.
  public var money: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsMoney] = []

  ///Список ценно-бумажных позиций портфеля.
  public var securities: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsSecurities] = []

  ///Список фьючерсов портфеля.
  public var futures: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsFutures] = []

  ///Список опционов портфеля.
  public var options: [Tinkoff_Public_Invest_Api_Contract_V1_PositionsOptions] = []

  ///Дата и время операции в формате UTC.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Валютная позиция портфеля.
public struct Tinkoff_Public_Invest_Api_Contract_V1_PositionsMoney {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Доступное количество валютный позиций.
  public var availableValue: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _availableValue ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_availableValue = newValue}
  }
  /// Returns true if `availableValue` has been explicitly set.
  public var hasAvailableValue: Bool {return self._availableValue != nil}
  /// Clears the value of `availableValue`. Subsequent reads from it will return its default value.
  public mutating func clearAvailableValue() {self._availableValue = nil}

  ///Заблокированное количество валютный позиций.
  public var blockedValue: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _blockedValue ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_blockedValue = newValue}
  }
  /// Returns true if `blockedValue` has been explicitly set.
  public var hasBlockedValue: Bool {return self._blockedValue != nil}
  /// Clears the value of `blockedValue`. Subsequent reads from it will return its default value.
  public mutating func clearBlockedValue() {self._blockedValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _availableValue: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
  fileprivate var _blockedValue: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationState: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationType: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionStatus: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsAccountSubscriptionStatus: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationsRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationsResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_Operation: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationTrade: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest.CurrencyRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioPosition: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_VirtualPortfolioPosition: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsSecurities: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsFutures: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsOptions: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReport: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_DividendsForeignIssuerReport: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_AccountSubscriptionStatus: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationItem: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrade: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamRequest: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse.OneOf_Payload: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionStatus: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionData: @unchecked Sendable {}
extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsMoney: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_STATE_UNSPECIFIED"),
    1: .same(proto: "OPERATION_STATE_EXECUTED"),
    2: .same(proto: "OPERATION_STATE_CANCELED"),
    3: .same(proto: "OPERATION_STATE_PROGRESS"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "OPERATION_TYPE_INPUT"),
    2: .same(proto: "OPERATION_TYPE_BOND_TAX"),
    3: .same(proto: "OPERATION_TYPE_OUTPUT_SECURITIES"),
    4: .same(proto: "OPERATION_TYPE_OVERNIGHT"),
    5: .same(proto: "OPERATION_TYPE_TAX"),
    6: .same(proto: "OPERATION_TYPE_BOND_REPAYMENT_FULL"),
    7: .same(proto: "OPERATION_TYPE_SELL_CARD"),
    8: .same(proto: "OPERATION_TYPE_DIVIDEND_TAX"),
    9: .same(proto: "OPERATION_TYPE_OUTPUT"),
    10: .same(proto: "OPERATION_TYPE_BOND_REPAYMENT"),
    11: .same(proto: "OPERATION_TYPE_TAX_CORRECTION"),
    12: .same(proto: "OPERATION_TYPE_SERVICE_FEE"),
    13: .same(proto: "OPERATION_TYPE_BENEFIT_TAX"),
    14: .same(proto: "OPERATION_TYPE_MARGIN_FEE"),
    15: .same(proto: "OPERATION_TYPE_BUY"),
    16: .same(proto: "OPERATION_TYPE_BUY_CARD"),
    17: .same(proto: "OPERATION_TYPE_INPUT_SECURITIES"),
    18: .same(proto: "OPERATION_TYPE_SELL_MARGIN"),
    19: .same(proto: "OPERATION_TYPE_BROKER_FEE"),
    20: .same(proto: "OPERATION_TYPE_BUY_MARGIN"),
    21: .same(proto: "OPERATION_TYPE_DIVIDEND"),
    22: .same(proto: "OPERATION_TYPE_SELL"),
    23: .same(proto: "OPERATION_TYPE_COUPON"),
    24: .same(proto: "OPERATION_TYPE_SUCCESS_FEE"),
    25: .same(proto: "OPERATION_TYPE_DIVIDEND_TRANSFER"),
    26: .same(proto: "OPERATION_TYPE_ACCRUING_VARMARGIN"),
    27: .same(proto: "OPERATION_TYPE_WRITING_OFF_VARMARGIN"),
    28: .same(proto: "OPERATION_TYPE_DELIVERY_BUY"),
    29: .same(proto: "OPERATION_TYPE_DELIVERY_SELL"),
    30: .same(proto: "OPERATION_TYPE_TRACK_MFEE"),
    31: .same(proto: "OPERATION_TYPE_TRACK_PFEE"),
    32: .same(proto: "OPERATION_TYPE_TAX_PROGRESSIVE"),
    33: .same(proto: "OPERATION_TYPE_BOND_TAX_PROGRESSIVE"),
    34: .same(proto: "OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE"),
    35: .same(proto: "OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE"),
    36: .same(proto: "OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE"),
    37: .same(proto: "OPERATION_TYPE_TAX_REPO_PROGRESSIVE"),
    38: .same(proto: "OPERATION_TYPE_TAX_REPO"),
    39: .same(proto: "OPERATION_TYPE_TAX_REPO_HOLD"),
    40: .same(proto: "OPERATION_TYPE_TAX_REPO_REFUND"),
    41: .same(proto: "OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE"),
    42: .same(proto: "OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE"),
    43: .same(proto: "OPERATION_TYPE_DIV_EXT"),
    44: .same(proto: "OPERATION_TYPE_TAX_CORRECTION_COUPON"),
    45: .same(proto: "OPERATION_TYPE_CASH_FEE"),
    46: .same(proto: "OPERATION_TYPE_OUT_FEE"),
    47: .same(proto: "OPERATION_TYPE_OUT_STAMP_DUTY"),
    50: .same(proto: "OPERATION_TYPE_OUTPUT_SWIFT"),
    51: .same(proto: "OPERATION_TYPE_INPUT_SWIFT"),
    53: .same(proto: "OPERATION_TYPE_OUTPUT_ACQUIRING"),
    54: .same(proto: "OPERATION_TYPE_INPUT_ACQUIRING"),
    55: .same(proto: "OPERATION_TYPE_OUTPUT_PENALTY"),
    56: .same(proto: "OPERATION_TYPE_ADVICE_FEE"),
    57: .same(proto: "OPERATION_TYPE_TRANS_IIS_BS"),
    58: .same(proto: "OPERATION_TYPE_TRANS_BS_BS"),
    59: .same(proto: "OPERATION_TYPE_OUT_MULTI"),
    60: .same(proto: "OPERATION_TYPE_INP_MULTI"),
    61: .same(proto: "OPERATION_TYPE_OVER_PLACEMENT"),
    62: .same(proto: "OPERATION_TYPE_OVER_COM"),
    63: .same(proto: "OPERATION_TYPE_OVER_INCOME"),
    64: .same(proto: "OPERATION_TYPE_OPTION_EXPIRATION"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND"),
    3: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsAccountSubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND"),
    3: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "state"),
    5: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.state != rhs.state {return false}
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationsResponse) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "parent_operation_id"),
    3: .same(proto: "currency"),
    4: .same(proto: "payment"),
    5: .same(proto: "price"),
    6: .same(proto: "state"),
    7: .same(proto: "quantity"),
    8: .standard(proto: "quantity_rest"),
    9: .same(proto: "figi"),
    10: .standard(proto: "instrument_type"),
    11: .same(proto: "date"),
    12: .same(proto: "type"),
    13: .standard(proto: "operation_type"),
    14: .same(proto: "trades"),
    16: .standard(proto: "asset_uid"),
    17: .standard(proto: "position_uid"),
    18: .standard(proto: "instrument_uid"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _parentOperationID: String = String()
    var _currency: String = String()
    var _payment: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _state: Tinkoff_Public_Invest_Api_Contract_V1_OperationState = .unspecified
    var _quantity: Int64 = 0
    var _quantityRest: Int64 = 0
    var _figi: String = String()
    var _instrumentType: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _type: String = String()
    var _operationType: Tinkoff_Public_Invest_Api_Contract_V1_OperationType = .unspecified
    var _trades: [Tinkoff_Public_Invest_Api_Contract_V1_OperationTrade] = []
    var _assetUid: String = String()
    var _positionUid: String = String()
    var _instrumentUid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _parentOperationID = source._parentOperationID
      _currency = source._currency
      _payment = source._payment
      _price = source._price
      _state = source._state
      _quantity = source._quantity
      _quantityRest = source._quantityRest
      _figi = source._figi
      _instrumentType = source._instrumentType
      _date = source._date
      _type = source._type
      _operationType = source._operationType
      _trades = source._trades
      _assetUid = source._assetUid
      _positionUid = source._positionUid
      _instrumentUid = source._instrumentUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._parentOperationID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._payment) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._quantityRest) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._operationType) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._trades) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._assetUid) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._positionUid) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._parentOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentOperationID, fieldNumber: 2)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 3)
      }
      try { if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 7)
      }
      if _storage._quantityRest != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantityRest, fieldNumber: 8)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 9)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 10)
      }
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 12)
      }
      if _storage._operationType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._operationType, fieldNumber: 13)
      }
      if !_storage._trades.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._trades, fieldNumber: 14)
      }
      if !_storage._assetUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetUid, fieldNumber: 16)
      }
      if !_storage._positionUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionUid, fieldNumber: 17)
      }
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Operation, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._parentOperationID != rhs_storage._parentOperationID {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._quantityRest != rhs_storage._quantityRest {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._operationType != rhs_storage._operationType {return false}
        if _storage._trades != rhs_storage._trades {return false}
        if _storage._assetUid != rhs_storage._assetUid {return false}
        if _storage._positionUid != rhs_storage._positionUid {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationTrade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationTrade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_id"),
    2: .standard(proto: "date_time"),
    3: .same(proto: "quantity"),
    4: .same(proto: "price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tradeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dateTime) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tradeID.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeID, fieldNumber: 1)
    }
    try { if let v = self._dateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 3)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationTrade, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationTrade) -> Bool {
    if lhs.tradeID != rhs.tradeID {return false}
    if lhs._dateTime != rhs._dateTime {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._price != rhs._price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "currency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.currency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.currency != .rub {
      try visitor.visitSingularEnumField(value: self.currency, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioRequest.CurrencyRequest: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUB"),
    1: .same(proto: "USD"),
    2: .same(proto: "EUR"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_amount_shares"),
    2: .standard(proto: "total_amount_bonds"),
    3: .standard(proto: "total_amount_etf"),
    4: .standard(proto: "total_amount_currencies"),
    5: .standard(proto: "total_amount_futures"),
    6: .standard(proto: "expected_yield"),
    7: .same(proto: "positions"),
    8: .standard(proto: "account_id"),
    9: .standard(proto: "total_amount_options"),
    10: .standard(proto: "total_amount_sp"),
    11: .standard(proto: "total_amount_portfolio"),
    12: .standard(proto: "virtual_positions"),
  ]

  fileprivate class _StorageClass {
    var _totalAmountShares: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _totalAmountBonds: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _totalAmountEtf: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _totalAmountCurrencies: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _totalAmountFutures: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _expectedYield: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _positions: [Tinkoff_Public_Invest_Api_Contract_V1_PortfolioPosition] = []
    var _accountID: String = String()
    var _totalAmountOptions: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _totalAmountSp: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _totalAmountPortfolio: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _virtualPositions: [Tinkoff_Public_Invest_Api_Contract_V1_VirtualPortfolioPosition] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalAmountShares = source._totalAmountShares
      _totalAmountBonds = source._totalAmountBonds
      _totalAmountEtf = source._totalAmountEtf
      _totalAmountCurrencies = source._totalAmountCurrencies
      _totalAmountFutures = source._totalAmountFutures
      _expectedYield = source._expectedYield
      _positions = source._positions
      _accountID = source._accountID
      _totalAmountOptions = source._totalAmountOptions
      _totalAmountSp = source._totalAmountSp
      _totalAmountPortfolio = source._totalAmountPortfolio
      _virtualPositions = source._virtualPositions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountShares) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountBonds) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountEtf) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountCurrencies) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountFutures) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYield) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._positions) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._accountID) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountOptions) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountSp) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountPortfolio) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._virtualPositions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._totalAmountShares {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._totalAmountBonds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._totalAmountEtf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._totalAmountCurrencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._totalAmountFutures {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._expectedYield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._positions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positions, fieldNumber: 7)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 8)
      }
      try { if let v = _storage._totalAmountOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._totalAmountSp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._totalAmountPortfolio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._virtualPositions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._virtualPositions, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalAmountShares != rhs_storage._totalAmountShares {return false}
        if _storage._totalAmountBonds != rhs_storage._totalAmountBonds {return false}
        if _storage._totalAmountEtf != rhs_storage._totalAmountEtf {return false}
        if _storage._totalAmountCurrencies != rhs_storage._totalAmountCurrencies {return false}
        if _storage._totalAmountFutures != rhs_storage._totalAmountFutures {return false}
        if _storage._expectedYield != rhs_storage._expectedYield {return false}
        if _storage._positions != rhs_storage._positions {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._totalAmountOptions != rhs_storage._totalAmountOptions {return false}
        if _storage._totalAmountSp != rhs_storage._totalAmountSp {return false}
        if _storage._totalAmountPortfolio != rhs_storage._totalAmountPortfolio {return false}
        if _storage._virtualPositions != rhs_storage._virtualPositions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "blocked"),
    3: .same(proto: "securities"),
    4: .standard(proto: "limits_loading_in_progress"),
    5: .same(proto: "futures"),
    6: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocked) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.securities) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.limitsLoadingInProgress) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.futures) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 1)
    }
    if !self.blocked.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocked, fieldNumber: 2)
    }
    if !self.securities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.securities, fieldNumber: 3)
    }
    if self.limitsLoadingInProgress != false {
      try visitor.visitSingularBoolField(value: self.limitsLoadingInProgress, fieldNumber: 4)
    }
    if !self.futures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futures, fieldNumber: 5)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsResponse) -> Bool {
    if lhs.money != rhs.money {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.securities != rhs.securities {return false}
    if lhs.limitsLoadingInProgress != rhs.limitsLoadingInProgress {return false}
    if lhs.futures != rhs.futures {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawLimitsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawLimitsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "blocked"),
    3: .standard(proto: "blocked_guarantee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocked) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blockedGuarantee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 1)
    }
    if !self.blocked.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocked, fieldNumber: 2)
    }
    if !self.blockedGuarantee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockedGuarantee, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_WithdrawLimitsResponse) -> Bool {
    if lhs.money != rhs.money {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.blockedGuarantee != rhs.blockedGuarantee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_type"),
    3: .same(proto: "quantity"),
    4: .standard(proto: "average_position_price"),
    5: .standard(proto: "expected_yield"),
    6: .standard(proto: "current_nkd"),
    7: .standard(proto: "average_position_price_pt"),
    8: .standard(proto: "current_price"),
    9: .standard(proto: "average_position_price_fifo"),
    10: .standard(proto: "quantity_lots"),
    21: .same(proto: "blocked"),
    22: .standard(proto: "blocked_lots"),
    24: .standard(proto: "position_uid"),
    25: .standard(proto: "instrument_uid"),
    26: .standard(proto: "var_margin"),
    27: .standard(proto: "expected_yield_fifo"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _instrumentType: String = String()
    var _quantity: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _averagePositionPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _expectedYield: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _currentNkd: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _averagePositionPricePt: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _currentPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _averagePositionPriceFifo: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _quantityLots: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _blocked: Bool = false
    var _blockedLots: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _positionUid: String = String()
    var _instrumentUid: String = String()
    var _varMargin: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _expectedYieldFifo: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _instrumentType = source._instrumentType
      _quantity = source._quantity
      _averagePositionPrice = source._averagePositionPrice
      _expectedYield = source._expectedYield
      _currentNkd = source._currentNkd
      _averagePositionPricePt = source._averagePositionPricePt
      _currentPrice = source._currentPrice
      _averagePositionPriceFifo = source._averagePositionPriceFifo
      _quantityLots = source._quantityLots
      _blocked = source._blocked
      _blockedLots = source._blockedLots
      _positionUid = source._positionUid
      _instrumentUid = source._instrumentUid
      _varMargin = source._varMargin
      _expectedYieldFifo = source._expectedYieldFifo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._quantity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPrice) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYield) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._currentNkd) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPricePt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._currentPrice) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPriceFifo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._quantityLots) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._blocked) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._blockedLots) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._positionUid) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._varMargin) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYieldFifo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 2)
      }
      try { if let v = _storage._quantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._averagePositionPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expectedYield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._currentNkd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._averagePositionPricePt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._currentPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._averagePositionPriceFifo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._quantityLots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._blocked != false {
        try visitor.visitSingularBoolField(value: _storage._blocked, fieldNumber: 21)
      }
      try { if let v = _storage._blockedLots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._positionUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionUid, fieldNumber: 24)
      }
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 25)
      }
      try { if let v = _storage._varMargin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._expectedYieldFifo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioPosition, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioPosition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._averagePositionPrice != rhs_storage._averagePositionPrice {return false}
        if _storage._expectedYield != rhs_storage._expectedYield {return false}
        if _storage._currentNkd != rhs_storage._currentNkd {return false}
        if _storage._averagePositionPricePt != rhs_storage._averagePositionPricePt {return false}
        if _storage._currentPrice != rhs_storage._currentPrice {return false}
        if _storage._averagePositionPriceFifo != rhs_storage._averagePositionPriceFifo {return false}
        if _storage._quantityLots != rhs_storage._quantityLots {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        if _storage._blockedLots != rhs_storage._blockedLots {return false}
        if _storage._positionUid != rhs_storage._positionUid {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        if _storage._varMargin != rhs_storage._varMargin {return false}
        if _storage._expectedYieldFifo != rhs_storage._expectedYieldFifo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_VirtualPortfolioPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VirtualPortfolioPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_uid"),
    2: .standard(proto: "instrument_uid"),
    3: .same(proto: "figi"),
    4: .standard(proto: "instrument_type"),
    5: .same(proto: "quantity"),
    6: .standard(proto: "average_position_price"),
    7: .standard(proto: "expected_yield"),
    8: .standard(proto: "expected_yield_fifo"),
    9: .standard(proto: "expire_date"),
    10: .standard(proto: "current_price"),
    11: .standard(proto: "average_position_price_fifo"),
  ]

  fileprivate class _StorageClass {
    var _positionUid: String = String()
    var _instrumentUid: String = String()
    var _figi: String = String()
    var _instrumentType: String = String()
    var _quantity: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _averagePositionPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _expectedYield: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _expectedYieldFifo: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _expireDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currentPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _averagePositionPriceFifo: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _positionUid = source._positionUid
      _instrumentUid = source._instrumentUid
      _figi = source._figi
      _instrumentType = source._instrumentType
      _quantity = source._quantity
      _averagePositionPrice = source._averagePositionPrice
      _expectedYield = source._expectedYield
      _expectedYieldFifo = source._expectedYieldFifo
      _expireDate = source._expireDate
      _currentPrice = source._currentPrice
      _averagePositionPriceFifo = source._averagePositionPriceFifo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._positionUid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._quantity) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPrice) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYield) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYieldFifo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._expireDate) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._currentPrice) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPriceFifo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._positionUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionUid, fieldNumber: 1)
      }
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 2)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 3)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 4)
      }
      try { if let v = _storage._quantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._averagePositionPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._expectedYield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._expectedYieldFifo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._expireDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._currentPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._averagePositionPriceFifo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_VirtualPortfolioPosition, rhs: Tinkoff_Public_Invest_Api_Contract_V1_VirtualPortfolioPosition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._positionUid != rhs_storage._positionUid {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._averagePositionPrice != rhs_storage._averagePositionPrice {return false}
        if _storage._expectedYield != rhs_storage._expectedYield {return false}
        if _storage._expectedYieldFifo != rhs_storage._expectedYieldFifo {return false}
        if _storage._expireDate != rhs_storage._expireDate {return false}
        if _storage._currentPrice != rhs_storage._currentPrice {return false}
        if _storage._averagePositionPriceFifo != rhs_storage._averagePositionPriceFifo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsSecurities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsSecurities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "blocked"),
    3: .same(proto: "balance"),
    4: .standard(proto: "position_uid"),
    5: .standard(proto: "instrument_uid"),
    11: .standard(proto: "exchange_blocked"),
    16: .standard(proto: "instrument_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.positionUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.exchangeBlocked) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.instrumentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 3)
    }
    if !self.positionUid.isEmpty {
      try visitor.visitSingularStringField(value: self.positionUid, fieldNumber: 4)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 5)
    }
    if self.exchangeBlocked != false {
      try visitor.visitSingularBoolField(value: self.exchangeBlocked, fieldNumber: 11)
    }
    if !self.instrumentType.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentType, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSecurities, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSecurities) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.positionUid != rhs.positionUid {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.exchangeBlocked != rhs.exchangeBlocked {return false}
    if lhs.instrumentType != rhs.instrumentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsFutures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsFutures"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "blocked"),
    3: .same(proto: "balance"),
    4: .standard(proto: "position_uid"),
    5: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.positionUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 3)
    }
    if !self.positionUid.isEmpty {
      try visitor.visitSingularStringField(value: self.positionUid, fieldNumber: 4)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsFutures, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsFutures) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.positionUid != rhs.positionUid {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_uid"),
    2: .standard(proto: "instrument_uid"),
    11: .same(proto: "blocked"),
    21: .same(proto: "balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.positionUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 21: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.positionUid.isEmpty {
      try visitor.visitSingularStringField(value: self.positionUid, fieldNumber: 1)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 2)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 11)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 21)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsOptions, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsOptions) -> Bool {
    if lhs.positionUid != rhs.positionUid {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrokerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_broker_report_request"),
    2: .standard(proto: "get_broker_report_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateBrokerReportRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateBrokerReportRequest(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getBrokerReportRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getBrokerReportRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateBrokerReportRequest?: try {
      guard case .generateBrokerReportRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getBrokerReportRequest?: try {
      guard case .getBrokerReportRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrokerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_broker_report_response"),
    2: .standard(proto: "get_broker_report_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateBrokerReportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateBrokerReportResponse(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getBrokerReportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getBrokerReportResponse(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateBrokerReportResponse?: try {
      guard case .generateBrokerReportResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getBrokerReportResponse?: try {
      guard case .getBrokerReportResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReportResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateBrokerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateBrokerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateBrokerReportResponse) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBrokerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBrokerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "broker_report"),
    2: .same(proto: "itemsCount"),
    3: .same(proto: "pagesCount"),
    4: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.brokerReport) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.itemsCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pagesCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.brokerReport.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.brokerReport, fieldNumber: 1)
    }
    if self.itemsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.itemsCount, fieldNumber: 2)
    }
    if self.pagesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pagesCount, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBrokerReportResponse) -> Bool {
    if lhs.brokerReport != rhs.brokerReport {return false}
    if lhs.itemsCount != rhs.itemsCount {return false}
    if lhs.pagesCount != rhs.pagesCount {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_BrokerReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrokerReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_id"),
    2: .standard(proto: "order_id"),
    3: .same(proto: "figi"),
    4: .standard(proto: "execute_sign"),
    5: .standard(proto: "trade_datetime"),
    6: .same(proto: "exchange"),
    7: .standard(proto: "class_code"),
    8: .same(proto: "direction"),
    9: .same(proto: "name"),
    10: .same(proto: "ticker"),
    11: .same(proto: "price"),
    12: .same(proto: "quantity"),
    13: .standard(proto: "order_amount"),
    14: .standard(proto: "aci_value"),
    15: .standard(proto: "total_order_amount"),
    16: .standard(proto: "broker_commission"),
    17: .standard(proto: "exchange_commission"),
    18: .standard(proto: "exchange_clearing_commission"),
    19: .standard(proto: "repo_rate"),
    20: .same(proto: "party"),
    21: .standard(proto: "clear_value_date"),
    22: .standard(proto: "sec_value_date"),
    23: .standard(proto: "broker_status"),
    24: .standard(proto: "separate_agreement_type"),
    25: .standard(proto: "separate_agreement_number"),
    26: .standard(proto: "separate_agreement_date"),
    27: .standard(proto: "delivery_type"),
  ]

  fileprivate class _StorageClass {
    var _tradeID: String = String()
    var _orderID: String = String()
    var _figi: String = String()
    var _executeSign: String = String()
    var _tradeDatetime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _exchange: String = String()
    var _classCode: String = String()
    var _direction: String = String()
    var _name: String = String()
    var _ticker: String = String()
    var _price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _quantity: Int64 = 0
    var _orderAmount: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _aciValue: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _totalOrderAmount: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _brokerCommission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _exchangeCommission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _exchangeClearingCommission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _repoRate: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _party: String = String()
    var _clearValueDate_p: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _secValueDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _brokerStatus: String = String()
    var _separateAgreementType: String = String()
    var _separateAgreementNumber: String = String()
    var _separateAgreementDate: String = String()
    var _deliveryType: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tradeID = source._tradeID
      _orderID = source._orderID
      _figi = source._figi
      _executeSign = source._executeSign
      _tradeDatetime = source._tradeDatetime
      _exchange = source._exchange
      _classCode = source._classCode
      _direction = source._direction
      _name = source._name
      _ticker = source._ticker
      _price = source._price
      _quantity = source._quantity
      _orderAmount = source._orderAmount
      _aciValue = source._aciValue
      _totalOrderAmount = source._totalOrderAmount
      _brokerCommission = source._brokerCommission
      _exchangeCommission = source._exchangeCommission
      _exchangeClearingCommission = source._exchangeClearingCommission
      _repoRate = source._repoRate
      _party = source._party
      _clearValueDate_p = source._clearValueDate_p
      _secValueDate = source._secValueDate
      _brokerStatus = source._brokerStatus
      _separateAgreementType = source._separateAgreementType
      _separateAgreementNumber = source._separateAgreementNumber
      _separateAgreementDate = source._separateAgreementDate
      _deliveryType = source._deliveryType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._tradeID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._orderID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._executeSign) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._tradeDatetime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._direction) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._orderAmount) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._aciValue) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._totalOrderAmount) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._brokerCommission) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._exchangeCommission) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._exchangeClearingCommission) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._repoRate) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._party) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._clearValueDate_p) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._secValueDate) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._brokerStatus) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._separateAgreementType) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._separateAgreementNumber) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._separateAgreementDate) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._deliveryType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._tradeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tradeID, fieldNumber: 1)
      }
      if !_storage._orderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderID, fieldNumber: 2)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 3)
      }
      if !_storage._executeSign.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executeSign, fieldNumber: 4)
      }
      try { if let v = _storage._tradeDatetime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 6)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 7)
      }
      if !_storage._direction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._direction, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 10)
      }
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 12)
      }
      try { if let v = _storage._orderAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._aciValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._totalOrderAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._brokerCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._exchangeCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._exchangeClearingCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._repoRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._party.isEmpty {
        try visitor.visitSingularStringField(value: _storage._party, fieldNumber: 20)
      }
      try { if let v = _storage._clearValueDate_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._secValueDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._brokerStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brokerStatus, fieldNumber: 23)
      }
      if !_storage._separateAgreementType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._separateAgreementType, fieldNumber: 24)
      }
      if !_storage._separateAgreementNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._separateAgreementNumber, fieldNumber: 25)
      }
      if !_storage._separateAgreementDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._separateAgreementDate, fieldNumber: 26)
      }
      if !_storage._deliveryType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deliveryType, fieldNumber: 27)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReport, rhs: Tinkoff_Public_Invest_Api_Contract_V1_BrokerReport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tradeID != rhs_storage._tradeID {return false}
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._executeSign != rhs_storage._executeSign {return false}
        if _storage._tradeDatetime != rhs_storage._tradeDatetime {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._orderAmount != rhs_storage._orderAmount {return false}
        if _storage._aciValue != rhs_storage._aciValue {return false}
        if _storage._totalOrderAmount != rhs_storage._totalOrderAmount {return false}
        if _storage._brokerCommission != rhs_storage._brokerCommission {return false}
        if _storage._exchangeCommission != rhs_storage._exchangeCommission {return false}
        if _storage._exchangeClearingCommission != rhs_storage._exchangeClearingCommission {return false}
        if _storage._repoRate != rhs_storage._repoRate {return false}
        if _storage._party != rhs_storage._party {return false}
        if _storage._clearValueDate_p != rhs_storage._clearValueDate_p {return false}
        if _storage._secValueDate != rhs_storage._secValueDate {return false}
        if _storage._brokerStatus != rhs_storage._brokerStatus {return false}
        if _storage._separateAgreementType != rhs_storage._separateAgreementType {return false}
        if _storage._separateAgreementNumber != rhs_storage._separateAgreementNumber {return false}
        if _storage._separateAgreementDate != rhs_storage._separateAgreementDate {return false}
        if _storage._deliveryType != rhs_storage._deliveryType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_div_foreign_issuer_report"),
    2: .standard(proto: "get_div_foreign_issuer_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateDivForeignIssuerReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateDivForeignIssuerReport(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getDivForeignIssuerReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getDivForeignIssuerReport(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateDivForeignIssuerReport?: try {
      guard case .generateDivForeignIssuerReport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getDivForeignIssuerReport?: try {
      guard case .getDivForeignIssuerReport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_div_foreign_issuer_report_response"),
    2: .standard(proto: "div_foreign_issuer_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateDivForeignIssuerReportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateDivForeignIssuerReportResponse(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .divForeignIssuerReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .divForeignIssuerReport(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateDivForeignIssuerReportResponse?: try {
      guard case .generateDivForeignIssuerReportResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .divForeignIssuerReport?: try {
      guard case .divForeignIssuerReport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateDividendsForeignIssuerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateDividendsForeignIssuerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GenerateDividendsForeignIssuerReportResponse) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dividends_foreign_issuer_report"),
    2: .same(proto: "itemsCount"),
    3: .same(proto: "pagesCount"),
    4: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dividendsForeignIssuerReport) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.itemsCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pagesCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dividendsForeignIssuerReport.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dividendsForeignIssuerReport, fieldNumber: 1)
    }
    if self.itemsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.itemsCount, fieldNumber: 2)
    }
    if self.pagesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pagesCount, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsForeignIssuerReportResponse) -> Bool {
    if lhs.dividendsForeignIssuerReport != rhs.dividendsForeignIssuerReport {return false}
    if lhs.itemsCount != rhs.itemsCount {return false}
    if lhs.pagesCount != rhs.pagesCount {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_DividendsForeignIssuerReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DividendsForeignIssuerReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_date"),
    2: .standard(proto: "payment_date"),
    3: .standard(proto: "security_name"),
    4: .same(proto: "isin"),
    5: .standard(proto: "issuer_country"),
    6: .same(proto: "quantity"),
    7: .same(proto: "dividend"),
    8: .standard(proto: "external_commission"),
    9: .standard(proto: "dividend_gross"),
    10: .same(proto: "tax"),
    11: .standard(proto: "dividend_amount"),
    12: .same(proto: "currency"),
  ]

  fileprivate class _StorageClass {
    var _recordDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _securityName: String = String()
    var _isin: String = String()
    var _issuerCountry: String = String()
    var _quantity: Int64 = 0
    var _dividend: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _externalCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dividendGross: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _tax: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dividendAmount: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _currency: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _recordDate = source._recordDate
      _paymentDate = source._paymentDate
      _securityName = source._securityName
      _isin = source._isin
      _issuerCountry = source._issuerCountry
      _quantity = source._quantity
      _dividend = source._dividend
      _externalCommission = source._externalCommission
      _dividendGross = source._dividendGross
      _tax = source._tax
      _dividendAmount = source._dividendAmount
      _currency = source._currency
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._recordDate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._paymentDate) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._securityName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._issuerCountry) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._dividend) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._externalCommission) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dividendGross) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._tax) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dividendAmount) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._recordDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._paymentDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if !_storage._issuerCountry.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuerCountry, fieldNumber: 5)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 6)
      }
      try { if let v = _storage._dividend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._externalCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dividendGross {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._tax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dividendAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_DividendsForeignIssuerReport, rhs: Tinkoff_Public_Invest_Api_Contract_V1_DividendsForeignIssuerReport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._recordDate != rhs_storage._recordDate {return false}
        if _storage._paymentDate != rhs_storage._paymentDate {return false}
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._issuerCountry != rhs_storage._issuerCountry {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._dividend != rhs_storage._dividend {return false}
        if _storage._externalCommission != rhs_storage._externalCommission {return false}
        if _storage._dividendGross != rhs_storage._dividendGross {return false}
        if _storage._tax != rhs_storage._tax {return false}
        if _storage._dividendAmount != rhs_storage._dividendAmount {return false}
        if _storage._currency != rhs_storage._currency {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamRequest) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .same(proto: "portfolio"),
    3: .same(proto: "ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscriptions(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .portfolio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .portfolio(v)
        }
      }()
      case 3: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscriptions?: try {
      guard case .subscriptions(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .portfolio?: try {
      guard case .portfolio(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioStreamResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioSubscriptionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PortfolioSubscriptionResult) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AccountSubscriptionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountSubscriptionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    6: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AccountSubscriptionStatus, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AccountSubscriptionStatus) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOperationsByCursorRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "instrument_id"),
    6: .same(proto: "from"),
    7: .same(proto: "to"),
    11: .same(proto: "cursor"),
    12: .same(proto: "limit"),
    13: .standard(proto: "operation_types"),
    14: .same(proto: "state"),
    15: .standard(proto: "without_commissions"),
    16: .standard(proto: "without_trades"),
    17: .standard(proto: "without_overnights"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 13: try { try decoder.decodeRepeatedEnumField(value: &self.operationTypes) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.withoutCommissions) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.withoutTrades) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.withoutOvernights) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 11)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 12)
    }
    if !self.operationTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.operationTypes, fieldNumber: 13)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 14)
    }
    if self.withoutCommissions != false {
      try visitor.visitSingularBoolField(value: self.withoutCommissions, fieldNumber: 15)
    }
    if self.withoutTrades != false {
      try visitor.visitSingularBoolField(value: self.withoutTrades, fieldNumber: 16)
    }
    if self.withoutOvernights != false {
      try visitor.visitSingularBoolField(value: self.withoutOvernights, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.operationTypes != rhs.operationTypes {return false}
    if lhs.state != rhs.state {return false}
    if lhs.withoutCommissions != rhs.withoutCommissions {return false}
    if lhs.withoutTrades != rhs.withoutTrades {return false}
    if lhs.withoutOvernights != rhs.withoutOvernights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOperationsByCursorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_next"),
    2: .standard(proto: "next_cursor"),
    6: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasNext_p) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextCursor) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasNext_p != false {
      try visitor.visitSingularBoolField(value: self.hasNext_p, fieldNumber: 1)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOperationsByCursorResponse) -> Bool {
    if lhs.hasNext_p != rhs.hasNext_p {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    6: .standard(proto: "broker_account_id"),
    16: .same(proto: "id"),
    17: .standard(proto: "parent_operation_id"),
    18: .same(proto: "name"),
    21: .same(proto: "date"),
    22: .same(proto: "type"),
    23: .same(proto: "description"),
    24: .same(proto: "state"),
    31: .standard(proto: "instrument_uid"),
    32: .same(proto: "figi"),
    33: .standard(proto: "instrument_type"),
    34: .standard(proto: "instrument_kind"),
    35: .standard(proto: "position_uid"),
    41: .same(proto: "payment"),
    42: .same(proto: "price"),
    43: .same(proto: "commission"),
    44: .same(proto: "yield"),
    45: .standard(proto: "yield_relative"),
    46: .standard(proto: "accrued_int"),
    51: .same(proto: "quantity"),
    52: .standard(proto: "quantity_rest"),
    53: .standard(proto: "quantity_done"),
    56: .standard(proto: "cancel_date_time"),
    57: .standard(proto: "cancel_reason"),
    61: .standard(proto: "trades_info"),
    64: .standard(proto: "asset_uid"),
  ]

  fileprivate class _StorageClass {
    var _cursor: String = String()
    var _brokerAccountID: String = String()
    var _id: String = String()
    var _parentOperationID: String = String()
    var _name: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _type: Tinkoff_Public_Invest_Api_Contract_V1_OperationType = .unspecified
    var _description_p: String = String()
    var _state: Tinkoff_Public_Invest_Api_Contract_V1_OperationState = .unspecified
    var _instrumentUid: String = String()
    var _figi: String = String()
    var _instrumentType: String = String()
    var _instrumentKind: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentType = .unspecified
    var _positionUid: String = String()
    var _payment: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _price: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _commission: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _yield: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _yieldRelative: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _accruedInt: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _quantity: Int64 = 0
    var _quantityRest: Int64 = 0
    var _quantityDone: Int64 = 0
    var _cancelDateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cancelReason: String = String()
    var _tradesInfo: Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades? = nil
    var _assetUid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cursor = source._cursor
      _brokerAccountID = source._brokerAccountID
      _id = source._id
      _parentOperationID = source._parentOperationID
      _name = source._name
      _date = source._date
      _type = source._type
      _description_p = source._description_p
      _state = source._state
      _instrumentUid = source._instrumentUid
      _figi = source._figi
      _instrumentType = source._instrumentType
      _instrumentKind = source._instrumentKind
      _positionUid = source._positionUid
      _payment = source._payment
      _price = source._price
      _commission = source._commission
      _yield = source._yield
      _yieldRelative = source._yieldRelative
      _accruedInt = source._accruedInt
      _quantity = source._quantity
      _quantityRest = source._quantityRest
      _quantityDone = source._quantityDone
      _cancelDateTime = source._cancelDateTime
      _cancelReason = source._cancelReason
      _tradesInfo = source._tradesInfo
      _assetUid = source._assetUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._cursor) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._brokerAccountID) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._parentOperationID) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 34: try { try decoder.decodeSingularEnumField(value: &_storage._instrumentKind) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._positionUid) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._payment) }()
        case 42: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._commission) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._yield) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._yieldRelative) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._accruedInt) }()
        case 51: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 52: try { try decoder.decodeSingularInt64Field(value: &_storage._quantityRest) }()
        case 53: try { try decoder.decodeSingularInt64Field(value: &_storage._quantityDone) }()
        case 56: try { try decoder.decodeSingularMessageField(value: &_storage._cancelDateTime) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._cancelReason) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._tradesInfo) }()
        case 64: try { try decoder.decodeSingularStringField(value: &_storage._assetUid) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._cursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cursor, fieldNumber: 1)
      }
      if !_storage._brokerAccountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brokerAccountID, fieldNumber: 6)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 16)
      }
      if !_storage._parentOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentOperationID, fieldNumber: 17)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 18)
      }
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 22)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 23)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 24)
      }
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 31)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 32)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 33)
      }
      if _storage._instrumentKind != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._instrumentKind, fieldNumber: 34)
      }
      if !_storage._positionUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionUid, fieldNumber: 35)
      }
      try { if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._commission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._yield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._yieldRelative {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._accruedInt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 51)
      }
      if _storage._quantityRest != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantityRest, fieldNumber: 52)
      }
      if _storage._quantityDone != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantityDone, fieldNumber: 53)
      }
      try { if let v = _storage._cancelDateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      } }()
      if !_storage._cancelReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cancelReason, fieldNumber: 57)
      }
      try { if let v = _storage._tradesInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      if !_storage._assetUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetUid, fieldNumber: 64)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationItem, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cursor != rhs_storage._cursor {return false}
        if _storage._brokerAccountID != rhs_storage._brokerAccountID {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._parentOperationID != rhs_storage._parentOperationID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._instrumentKind != rhs_storage._instrumentKind {return false}
        if _storage._positionUid != rhs_storage._positionUid {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._commission != rhs_storage._commission {return false}
        if _storage._yield != rhs_storage._yield {return false}
        if _storage._yieldRelative != rhs_storage._yieldRelative {return false}
        if _storage._accruedInt != rhs_storage._accruedInt {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._quantityRest != rhs_storage._quantityRest {return false}
        if _storage._quantityDone != rhs_storage._quantityDone {return false}
        if _storage._cancelDateTime != rhs_storage._cancelDateTime {return false}
        if _storage._cancelReason != rhs_storage._cancelReason {return false}
        if _storage._tradesInfo != rhs_storage._tradesInfo {return false}
        if _storage._assetUid != rhs_storage._assetUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationItemTrades"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "trades"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrades) -> Bool {
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationItemTrade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    6: .same(proto: "date"),
    11: .same(proto: "quantity"),
    16: .same(proto: "price"),
    21: .same(proto: "yield"),
    22: .standard(proto: "yield_relative"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.num) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._yield) }()
      case 22: try { try decoder.decodeSingularMessageField(value: &self._yieldRelative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.num.isEmpty {
      try visitor.visitSingularStringField(value: self.num, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 11)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._yield {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    } }()
    try { if let v = self._yieldRelative {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrade, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OperationItemTrade) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs._date != rhs._date {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._price != rhs._price {return false}
    if lhs._yield != rhs._yield {return false}
    if lhs._yieldRelative != rhs._yieldRelative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamRequest) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .same(proto: "position"),
    3: .same(proto: "ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscriptions(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_PositionData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .position(v)
        }
      }()
      case 3: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscriptions?: try {
      guard case .subscriptions(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .position?: try {
      guard case .position(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsStreamResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsSubscriptionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionResult) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsSubscriptionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    6: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.subscriptionStatus != .positionsSubscriptionStatusUnspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionStatus, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsSubscriptionStatus) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "money"),
    3: .same(proto: "securities"),
    4: .same(proto: "futures"),
    5: .same(proto: "options"),
    6: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.securities) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.futures) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 2)
    }
    if !self.securities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.securities, fieldNumber: 3)
    }
    if !self.futures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futures, fieldNumber: 4)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 5)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionData, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionData) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.money != rhs.money {return false}
    if lhs.securities != rhs.securities {return false}
    if lhs.futures != rhs.futures {return false}
    if lhs.options != rhs.options {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_PositionsMoney: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsMoney"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_value"),
    2: .standard(proto: "blocked_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._availableValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockedValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._availableValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockedValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsMoney, rhs: Tinkoff_Public_Invest_Api_Contract_V1_PositionsMoney) -> Bool {
    if lhs._availableValue != rhs._availableValue {return false}
    if lhs._blockedValue != rhs._blockedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
